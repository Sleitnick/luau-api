var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Luau C API","text":"<p>Unofficial documentation of the Luau C API. Much of the Luau API is identical to the Lua 5.1 API. However, there are many additions, removals, and changes within Luau. Using the Lua 5.1 docs exclusively is not sufficient.</p> <p>API Reference</p> <p>The Reference page contains documentation on the Luau C API.</p> <p>Guides</p> <p>The Guides page contains various how-to guides for extending Luau, such as creating efficient userdata types, using native code generation, sandboxing, and much more.</p> <p>This website, including all of its content and code examples, are in the public domain (officially under the \"unlicense\" license). Please feel free to take and use the code examples however you would like.</p>"},{"location":"reference.html","title":"Luau C API Reference","text":""},{"location":"reference.html#state-manipulation","title":"State Manipulation","text":""},{"location":"reference.html#lua_newstate","title":"<code>lua_newstate</code>","text":"<p><code>lua_State* lua_newstate(lua_Alloc f, void* ud)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>f</code>: Luau allocator function.</li> <li><code>ud</code>: Opaque userdata pointer that is passed to the allocator function.</li> </ul> <p>Creates a new Luau state. If the allocator fails to allocate memory for the new state, this function will return <code>nullptr</code>. Use <code>lua_close()</code> to close the state once done.</p> <p>The allocator function is used for all Luau memory allocations, including the initial construction of the state itself.</p> <pre><code>lua_State* L = lua_newstate(allocator, nullptr);\nlua_close(L);\n</code></pre> Allocator Example <p>This is functionally identical to the allocator function used by the <code>luaL_newstate</code> helper function. <pre><code>static void* allocator(void* ud, void* ptr, size_t old_size, size_t new_size) {\n    (void)ud; (void)old_size; // Not using these\n\n    // new_size of 0 indicates the allocator should free the ptr\n    if (new_size == 0) {\n        free(ptr);\n        return nullptr;\n    }\n\n    return realloc(ptr, new_size);\n}\n\nlua_State* L = lua_newstate(allocator, nullptr);\n</code></pre></p>"},{"location":"reference.html#lual_newstate","title":"<code>luaL_newstate</code>","text":"<p><code>lua_State* luaL_newstate()</code> <code>[-0, +0, -]</code></p> <p>A simplified version of <code>lua_newstate</code> that uses the default allocator, which uses the standard <code>free</code> and <code>realloc</code> memory functions.</p>"},{"location":"reference.html#lua_close","title":"<code>lua_close</code>","text":"<p><code>void lua_close()</code> <code>[-0, +0, -]</code></p> <p>Closes the Luau state. Luau objects are garbage collected and any dynamic memory is freed.</p> Smart Pointer Example <p>In modern C++, smart pointers can help with memory management. Here is an example of using a smart pointer that wraps around a Luau state and automatically calls <code>lua_close()</code> when dereferenced. <pre><code>std::unique_ptr&lt;lua_State, void(*)(lua_State*)&gt; state(luaL_newState(), lua_close);\n</code></pre></p>"},{"location":"reference.html#lua_newthread","title":"<code>lua_newthread</code>","text":"<p><code>lua_State* lua_newthread(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Parent thread</li> </ul> <p>Creates a new Luau thread.</p>"},{"location":"reference.html#lua_mainthread","title":"<code>lua_mainthread</code>","text":"<p><code>lua_State* lua_mainthread(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Returns the main Lua state (e.g. the state created from <code>lua_newstate()</code>).</p>"},{"location":"reference.html#lua_resetthread","title":"<code>lua_resetthread</code>","text":"<p><code>void lua_resetthread(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Resets the Lua thread.</p>"},{"location":"reference.html#lua_isthreadreset","title":"<code>lua_isthreadreset</code>","text":"<p><code>int lua_isthreadreset(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Checks if the Lua thread is reset.</p>"},{"location":"reference.html#lual_sandbox","title":"<code>luaL_sandbox</code>","text":"<p><code>lua_State* luaL_sandbox(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Parent thread</li> </ul> <p>Sandboxes the Luau state. All libraries, built-in metatables, and globals are set to read-only. This also activates \"safeenv\" (<code>lua_setsafeenv</code>) on the global table.</p> Example<pre><code>lua_State* L = luaL_newstate();\nluaL_openlibs(L);\n\n// Sandboxing AFTER libraries are open:\nluaL_sandbox(L);\n</code></pre>"},{"location":"reference.html#lual_sandboxthread","title":"<code>luaL_sandboxthread</code>","text":"<p><code>lua_State* luaL_sandboxthread(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Parent thread</li> </ul> <p>Sandboxes the given thread by creating a new global table that proxies the original global table.</p> <p>This is useful to set per \"script\" rather than every single thread that is created (i.e. it's best to not call <code>luaL_sandboxthread</code> within the <code>userthread</code> callback, as that can cause long metafield index chains, which will also throw errors at a certain depth).</p> Example<pre><code>// Load and run a script:\nint run_script(const std::string&amp; name, const std::string&amp; bytecode) {\n    int load_res = luau_load(L, (std::string(\"=\") + name).c_str(), bytecode.data(), bytecode.length(), 0);\n\n    if (load_res != 0) {\n        // ...handle error\n        return load_res;\n    }\n\n    lua_State* script = lua_newthread(L);\n    lua_pushvalue(L, -2);\n    lua_remove(L, -3);\n    lua_xmove(L, script, 1);\n\n    lua_sandboxthread(script);\n\n    int status = lua_resume(script, nullptr, 0);\n    // ...handle status\n}\n</code></pre>"},{"location":"reference.html#open-library-functions","title":"Open Library Functions","text":""},{"location":"reference.html#lual_openlibs","title":"<code>luaL_openlibs</code>","text":"<p><code>int luaL_openlibs(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens all built-in Luau libraries.</p> Example<pre><code>lua_State* L = luaL_newstate();\nluaL_openlibs(L);\n// ...\n</code></pre>"},{"location":"reference.html#luaopen_base","title":"<code>luaopen_base</code>","text":"<p><code>int luaopen_base(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the base global library functions, e.g. <code>print</code>, <code>error</code>, <code>tostring</code>, etc.</p> <p>Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_coroutine","title":"<code>luaopen_coroutine</code>","text":"<p><code>int luaopen_coroutine(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the coroutine library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_table","title":"<code>luaopen_table</code>","text":"<p><code>int luaopen_table(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the table library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_os","title":"<code>luaopen_os</code>","text":"<p><code>int luaopen_os(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the OS library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_string","title":"<code>luaopen_string</code>","text":"<p><code>int luaopen_string(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the string library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_bit32","title":"<code>luaopen_bit32</code>","text":"<p><code>int luaopen_bit32(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the bit32 library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_buffer","title":"<code>luaopen_buffer</code>","text":"<p><code>int luaopen_buffer(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the buffer library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_utf8","title":"<code>luaopen_utf8</code>","text":"<p><code>int luaopen_utf8(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the UTF-8 library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_math","title":"<code>luaopen_math</code>","text":"<p><code>int luaopen_math(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the math library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_debug","title":"<code>luaopen_debug</code>","text":"<p><code>int luaopen_debug(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the debug library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#luaopen_vector","title":"<code>luaopen_vector</code>","text":"<p><code>int luaopen_vector(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Opens the vector library. Use <code>luaL_openlibs</code> to open all built-in Luau libraries, including this one.</p>"},{"location":"reference.html#basic-stack-manipulation","title":"Basic Stack Manipulation","text":""},{"location":"reference.html#lua_absindex","title":"<code>lua_absindex</code>","text":"<p><code>int lua_absindex(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Index</li> </ul> <p>Gets the absolute stack index. For example, if <code>idx</code> is <code>-2</code>, and the stack has 5 items, this function will return <code>4</code>.</p>"},{"location":"reference.html#lua_gettop","title":"<code>lua_gettop</code>","text":"<p><code>int lua_gettop(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Gets the index representing the top of the stack. This also represents the number of items on the stack, since the stack index starts at 1. A stack size of 0 indicates an empty stack.</p> <p>A common use of <code>lua_gettop()</code> is to get the number of arguments in a function call.</p> <pre><code>int custom_fn(lua_State* L) {\n    int n_args = lua_gettop(L);\n    lua_pushfstring(\"there are %d arguments\", n_args);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lua_settop","title":"<code>lua_settop</code>","text":"<p><code>int lua_settop(lua_State* L, int idx)</code> <code>[-?, +?, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Top stack index</li> </ul> <p>Sets the top of the stack, essentially resizing it to the given index. If the new size is larger than the current size, the new elements in the stack will be filled with <code>nil</code> values. Setting the stack size to 0 will clear the stack entirely.</p> <pre><code>lua_settop(L, 0); // clear the stack\n</code></pre>"},{"location":"reference.html#lua_pop","title":"<code>lua_pop</code>","text":"<p><code>void lua_pop(lua_State* L, int n)</code> <code>[-n, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>n</code>: Number of items to pop</li> </ul> <p>Pops <code>n</code> values off the top of the stack.</p> Example<pre><code>// Assume lua_gettop(L) == 0 here\n\nlua_pushliteral(L, \"Hello\");\nlua_pushnumber(L, 85.2);\nlua_pushboolean(L, true);\nprintf(\"Size: %d\\n\", lua_gettop(L)); // Size: 3\n\nlua_pop(L, 2);\n\nprintf(\"Size: %d\\n\", lua_gettop(L)); // Size: 1\nprintf(\"Type: %s\\n\", luaL_typename(L, -1)); // string (top of stack is the \"Hello\" value now)\n</code></pre>"},{"location":"reference.html#lua_pushvalue","title":"<code>lua_pushvalue</code>","text":"<p><code>void lua_pushvalue(lua_State* L, int idx)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Pushes a copy of the value at index <code>idx</code> to the top of the stack.</p>"},{"location":"reference.html#lua_remove","title":"<code>lua_remove</code>","text":"<p><code>void lua_remove(lua_State* L, int idx)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Removes the value at the given stack index <code>idx</code>. All other values above the index are shifted down.</p> Example<pre><code>lua_pushinteger(L, 10);\nlua_pushboolean(L, true);\nlua_pushliteral(L, \"hello\");\n\nlua_remove(L, -2); // remove the 'true' value.\n\nprintf(\"%s\\n\", luaL_tostring(L, -2)); // 'hello'\n</code></pre>"},{"location":"reference.html#lua_insert","title":"<code>lua_insert</code>","text":"<p><code>void lua_insert(lua_State* L, int idx)</code> <code>[-1, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Moves the top stack element into the given index, shifting other values up first to give space. The element right under the top stack element becomes the new top element.</p> Example<pre><code>lua_pushboolean(L, true);\nlua_pushinteger(L, 10);\nlua_pushliteral(L, \"hello\");\nlua_pushinteger(L, 20);\n\n// Current stack order:\n// [-4] true\n// [-3] 10\n// [-2] hello\n// [-1] 20\n\n// Move the top value (20) to index -3.\n// The values below the top and above -3 are shifted up.\n// e.g. the '10' and 'hello' are shifted up first.\nlua_insert(L, -3);\n\n// New stack order:\n// [-4] true\n// [-3] 20\n// [-2] 10\n// [-1] hello\n</code></pre>"},{"location":"reference.html#lua_replace","title":"<code>lua_replace</code>","text":"<p><code>void lua_replace(lua_State* L, int idx)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Moves the top element over top of the <code>idx</code> stack index. The old value at <code>idx</code> is overwritten. The top element is popped.</p> Example<pre><code>lua_pushboolean(L, true);\nlua_pushinteger(L, 10);\nlua_pushliteral(L, \"hello\");\nlua_pushinteger(L, 20);\n\n// Current stack order:\n// [-4] true\n// [-3] 10\n// [-2] hello\n// [-1] 20\n\n// Move the top value (20) to index -3.\n// The values below the top and above -3 are shifted up.\n// e.g. the '10' and 'hello' are shifted up first.\nlua_replace(L, -3);\n\n// New stack order:\n// [-3] true\n// [-2] 20\n// [-1] hello\n</code></pre>"},{"location":"reference.html#lua_checkstack","title":"<code>lua_checkstack</code>","text":"<p><code>int lua_checkstack(lua_State* L, int size)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>size</code>: Desired stack size</li> </ul> <p>Ensures the stack is large enough to hold <code>size</code> more elements. This will only grow the stack, not shrink it. Returns true if successful, or false if it fails (e.g. the max stack size exceeded).</p> Example<pre><code>// Ensure there are at least 2 more slots on the stack:\nif (lua_checkstack(L, 2)) {\n    lua_pushinteger(L, 10);\n    lua_pushinteger(L, 20);\n}\n</code></pre>"},{"location":"reference.html#lual_checkstack","title":"<code>luaL_checkstack</code>","text":"<p><code>void luaL_checkstack(lua_State* L, int size, const char* msg)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>size</code>: Desired stack size</li> <li><code>msg</code>: Error message</li> </ul> <p>Ensures the stack is large enough to hold <code>size</code> more elements. This will only grow the stack, not shrink it. Throws an error if the stack cannot be resized to the desired size.</p> Example<pre><code>// Ensure there are at least 2 more slots on the stack:\nluaL_checkstack(L, 2, \"failed to grow stack for the two numbers\");\n\nlua_pushinteger(L, 10);\nlua_pushinteger(L, 20);\n</code></pre>"},{"location":"reference.html#lua_rawcheckstack","title":"<code>lua_rawcheckstack</code>","text":"<p><code>void lua_rawcheckstack(lua_State* L, int size)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>size</code>: Desired stack size</li> </ul> <p>Similar to <code>lua_checkstack</code>, except it bypasses the max stack limit.</p>"},{"location":"reference.html#lua_xmove","title":"<code>lua_xmove</code>","text":"<p><code>void lua_xmove(lua_State* from, lua_State* to, int n)</code> <code>[-?, +?, -]</code></p> <ul> <li><code>from</code>: Lua thread</li> <li><code>to</code>: Lua thread</li> <li><code>n</code>: Number of items to move</li> </ul> <p>Moves the top <code>n</code> elements in the <code>from</code> stack to the top of the <code>to</code> stack. This pops <code>n</code> values from the <code>from</code> stack and pushes <code>n</code> values to the <code>to</code> stack.</p> <p>Note: Both <code>from</code> and <code>to</code> states must share the same global state (e.g. the main state created with <code>lua_newstate</code>).</p> Example<pre><code>// Assume we have lua_State* A and B, both starting with empty stacks.\n\n// Add some items to 'A' stack:\nlua_pushboolean(A, true);\nlua_pushinteger(A, 10);\nlua_pushliteral(A, \"hello\");\n\n// Moves the top 2 values from 'A' to 'B' (e.g. '10' and 'hello')\nlua_xmove(A, B, 2);\n\nprintf(\"%d\\n\", lua_gettop(A)); // 1 (just the 'true' value remains)\nprintf(\"%d\\n\", lua_gettop(B)); // 2 (the '10' and 'hello' values)\n</code></pre>"},{"location":"reference.html#lua_xpush","title":"<code>lua_xpush</code>","text":"<p><code>void lua_xpush(lua_State* from, lua_State* to, int idx)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>from</code>: Lua thread</li> <li><code>to</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Pushes a value from the <code>from</code> state to the <code>to</code> state. The value at index <code>idx</code> in <code>from</code> is pushed to the top of the <code>to</code> stack. This is similar to <code>lua_pushvalue</code>, except the value is pushed to a different state.</p> <p>Similar to <code>lua_xmove</code>, both <code>from</code> and <code>to</code> must share the same global state.</p> Example<pre><code>// Push the value at index -2 within 'from' to the top of the 'to' stack:\nlua_xpush(from, to, -2);\n</code></pre>"},{"location":"reference.html#access-functions","title":"Access Functions","text":""},{"location":"reference.html#lua_iscfunction","title":"<code>lua_iscfunction</code>","text":"<p><code>int lua_iscfunction(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at the given stack index is a C function. Otherwise, returns <code>0</code>.</p>"},{"location":"reference.html#lua_islfunction","title":"<code>lua_isLfunction</code>","text":"<p><code>int lua_isLfunction(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at the given stack index is a Luau function. Otherwise, returns <code>0</code>.</p>"},{"location":"reference.html#lua_type","title":"<code>lua_type</code>","text":"<p><code>int lua_type(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the value type at the given stack index. If the stack index is invalid, this function returns <code>LUA_TNONE</code>.</p> <p>List of lua types:</p> <ul> <li><code>LUA_TNIL</code></li> <li><code>LUA_TBOOLEAN</code></li> <li><code>LUA_TLIGHTUSERDATA</code></li> <li><code>LUA_TNUMBER</code></li> <li><code>LUA_TVECTOR</code></li> <li><code>LUA_TSTRING</code></li> <li><code>LUA_TTABLE</code></li> <li><code>LUA_TFUNCTION</code></li> <li><code>LUA_TUSERDATA</code></li> <li><code>LUA_TTHREAD</code></li> <li><code>LUA_TBUFFER</code></li> </ul>"},{"location":"reference.html#lua_typename","title":"<code>lua_typename</code>","text":"<p><code>const char* lua_typename(lua_State* L, int tp)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tp</code>: Luau type</li> </ul> <p>Returns the name of the given type.</p> Example<pre><code>const char* thread_name = lua_type(L, LUA_TTHREAD);\nprintf(\"%s\\n\", thread_name); // &gt; \"thread\"\n</code></pre>"},{"location":"reference.html#lua_equal","title":"<code>lua_equal</code>","text":"<p><code>int lua_equal(lua_State* L, int idx1, int idx2)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx1</code>: Stack index</li> <li><code>idx2</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the values at <code>idx1</code> and <code>idx2</code> are equal. If applicable, this will call the <code>__eq</code> metatable function. Use <code>lua_rawequal</code> to avoid the metatable call. Returns <code>0</code> if the values are not equal (including if either of the indices are invalid).</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_pushliteral(L, \"hello\");\n\nif (lua_equal(L, -2, -1)) {\n    printf(\"equal\\n\");\n}\n</code></pre>"},{"location":"reference.html#lua_rawequal","title":"<code>lua_rawequal</code>","text":"<p><code>int lua_rawequal(lua_State* L, int idx1, int idx2)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx1</code>: Stack index</li> <li><code>idx2</code>: Stack index</li> </ul> <p>The same as <code>lua_equal</code>, except it does not call any metatable <code>__eq</code> functions.</p>"},{"location":"reference.html#lua_lessthan","title":"<code>lua_lessthan</code>","text":"<p><code>int lua_lessthan(lua_State* L, int idx1, int idx2)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx1</code>: Stack index</li> <li><code>idx2</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at <code>idx</code> is less than the value at <code>idx2</code>. Otherwise, returns <code>0</code>. This may call the <code>__lt</code> metamethod function. Also returns <code>0</code> if either index is invalid.</p>"},{"location":"reference.html#lua_namecallatom","title":"<code>lua_namecallatom</code>","text":"<p><code>const char* lua_namecallatom(lua_State* L, int* atom)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>atom</code>: Atom</li> </ul> <p>When called within a <code>__namecall</code> metamethod, this function returns the name of the called method. An optional atom value can be utilized as well.</p> Example<pre><code>static constexpr const char* kFoo = \"Foo\";\n\nstruct Foo {};\n\n// Handle namecalls, e.g. Luau calling \"foo:Hello()\"\nstatic int Foo_namecall(lua_State* L) {\n    const char* method = lua_namecallatom(L, nullptr);\n    if (strcmp(method, \"Hello\") == 0) {\n        // User called the 'Hello' method. Return \"Goodbye\":\n        lua_pushliteral(L, \"Goodbye\");\n        return 1;\n    }\n    luaL_error(L, \"unknown method %s\", method);\n}\n\n// Construct new Foo userdata:\nint new_Foo(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n    if (luaL_newmetatable(L, kFoo)) {\n        // Assign __namecall metamethod:\n        lua_pushcfunction(L, Foo_namecall, \"namecall\");\n        lua_rawsetfield(L, -2, \"__namecall\");\n    }\n    lua_setmetatable(L, -2);\n    return 1;\n}\n\nstatic const luaL_Reg[] Foo_lib = {\n    {\"new\", new_Foo},\n    {nullptr, nullptr},\n};\n\n// Called from setup code for Luau state:\nvoid open_Foo(lua_State* L) {\n    lua_register(L, Foo_lib);\n}\n</code></pre>"},{"location":"reference.html#lua_objlen","title":"<code>lua_objlen</code>","text":"<p><code>int lua_objlen(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the length of the value at the given stack index. This works for tables (array length), strings (string length), buffers (buffer size), and userdata (userdata size). For non-applicable types, this function will return <code>0</code>.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_newbuffer(L, 12);\nlua_newuserdata(L, 15);\nlua_pushinteger(L, 5);\n\nint n;\nn = lua_objlen(L, -4); // 5 (length of \"hello\")\nn = lua_objlen(L, -3); // 12 (size of buffer)\nn = lua_objlen(L, -2); // 15 (size of userdata)\nn = lua_objlen(L, -1); // 0 (integer type is N/A, thus 0 is returned)\n</code></pre>"},{"location":"reference.html#lua_tocfunction","title":"<code>lua_tocfunction</code>","text":"<p><code>lua_CFunction lua_tocfunction(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the C function at the given stack position. If the value is not a C function, this function returns <code>NULL</code>.</p> Example<pre><code>int hello() {\n  printf(\"hello\\n\");\n  return 0;\n}\n\nlua_pushcfunction(L, hello, \"hello\");\n\nlua_CFunction f = lua_tocfunction(L, -1);\nif (f) {\n  f(); // hello\n}\n</code></pre>"},{"location":"reference.html#lua_tothread","title":"<code>lua_tothread</code>","text":"<p><code>lua_State* lua_tothread(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the Luau thread at the given stack index, or <code>NULL</code> if the value is not a Luau thread.</p> Example<pre><code>lua_State* T = lua_newthread(L); // pushes T onto L's stack\nlua_State* thread = lua_tothread(L, -1); // retrieve T from L's stack\n// thread == T\n</code></pre>"},{"location":"reference.html#lua_topointer","title":"<code>lua_topointer</code>","text":"<p><code>void* lua_topointer(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns a pointer to the value at the given stack index. This works for userdata, lightuserdata, strings, tables, buffers, and functions.</p> <p>Note: This should only be used for debugging purposes.</p> Example<pre><code>void* buf = lua_newbuffer(L, 10);\n\nsize_t len;\nvoid* b = lua_tobuffer(L, -1, &amp;len);\n// b == buf\n// len == 10\n</code></pre>"},{"location":"reference.html#push-functions","title":"Push Functions","text":""},{"location":"reference.html#lua_pushnil","title":"<code>lua_pushnil</code>","text":"<p><code>void lua_pushnil(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Pushes <code>nil</code> to the Luau stack.</p> Example<pre><code>lua_pushnil(L);\n</code></pre>"},{"location":"reference.html#lua_pushcclosurek","title":"<code>lua_pushcclosurek</code>","text":"<p><code>void lua_pushcclosurek(lua_State* L, lua_CFunction fn, const char* debugname, int nup, lua_Continuation cont)</code> <code>[-n, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fn</code>: C Function</li> <li><code>debugname</code>: Debug name</li> <li><code>nup</code>: Number of upvalues to capture</li> <li><code>cont</code>: Continuation function to invoke</li> </ul> <p>Pushes the C function to the stack as a closure, which captures and pops <code>nup</code> upvalues from the top of the stack. The closure's continuation function is also assigned to <code>cont</code>.</p> <p>The continuation function is invoked when the closure is resumed.</p> Example<pre><code>int addition_cont(lua_State* L) {\n    double add = lua_tonumber(L, lua_upvalueindex(2)); // 4\n    double n = lua_tonumber(L, 1);\n    double sum = n + add;\n    lua_pushnumber(L, sum);\n    // Stop generator if sum exceeds 100 (this would obviously be bad if 'add' was &lt;= 0)\n    if (sum &gt; 100) {\n        return 1;\n    }\n    return lua_yield(L, 1);\n}\n\nint addition(lua_State* L) {\n    double start = lua_tonumber(L, lua_upvalueindex(1)); // 10\n    double add = lua_tonumber(L, lua_upvalueindex(2)); // 4\n    lua_pushnumber(L, start + add);\n    return lua_yield(L, 1);\n}\n\nint start_addition(lua_State* L) {\n    lua_pushvalue(L, 1);\n    lua_pushvalue(L, 2);\n    lua_pushcclosurek(L, addition, \"addition\", 2, addition_cont);\n}\n\n// Expose \"start_addition\" to Luau:\nset_global(L, \"start_addition\", start_addition);\n</code></pre> <pre><code>-- Start adder generator from 10 and add by 4:\nlocal adder = coroutine.wrap(start_addition(10, 4))\ndo\n    local sum = adder()\n    print(sum)\nuntil not sum\n</code></pre>"},{"location":"reference.html#lua_pushcclosure","title":"<code>lua_pushcclosure</code>","text":"<p><code>void lua_pushcclosure(lua_State* L, lua_CFunction fn, const char* debugname, int nup)</code> <code>[-n, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fn</code>: C Function</li> <li><code>debugname</code>: Debug name</li> <li><code>nup</code>: Number of upvalues to capture</li> </ul> <p>Equivalent to <code>lua_pushcclosurek</code>, but without any continuation function provided.</p>"},{"location":"reference.html#lua_pushcfunction","title":"<code>lua_pushcfunction</code>","text":"<p><code>void lua_pushcfunction(lua_State* L, lua_CFunction fn, const char* debugname)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fn</code>: C Function</li> <li><code>debugname</code>: Debug name</li> </ul> <p>Pushes the C function to the stack.</p> <p>Equivalent to <code>lua_pushcclosurek</code>, but without any upvalues nor any continuation function.</p> Example<pre><code>int multiply(lua_State* L) {\n    lua_pushnumber(L, lua_tonumber(L, 1) * lua_tonumber(L, 2));\n    return 1;\n}\n\nlua_pushcfunction(L, multiply, \"multiply\");\nlua_setglobal(L, \"multiply\");\n</code></pre> Luau Example<pre><code>print(\"2 * 5 = \" .. multiply(2, 5))\n</code></pre>"},{"location":"reference.html#lua_pushthread","title":"<code>lua_pushthread</code>","text":"<p><code>int lua_pushthread(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Pushes the thread (L) to the stack. Returns <code>1</code> if the thread is the main thread, otherwise <code>0</code>.</p> Example<pre><code>lua_pushthread(L);\n\nlua_State* T = lua_tothread(L, -1);\n// T == L\n</code></pre>"},{"location":"reference.html#lua_createtable","title":"<code>lua_createtable</code>","text":"<p><code>void lua_createtable(lua_State* L, int narr, int nrec)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>narr</code>: Array size</li> <li><code>nrec</code>: Dictionary size</li> </ul> <p>Pushes a new table onto the stack, allocating <code>narr</code> slots on the array portion and <code>nrec</code> slots on the dictionary portion. Use <code>lua_newtable</code> to create a table with zero size allocation, equivalent to <code>lua_createtable(0, 0)</code>.</p> <p>These allocated slots are not filled.</p> Example<pre><code>lua_createtable(L, 10, 0); // Push a new table onto the stack with 10 array slots allocated\n// 10 slots allocated, but not filled, e.g. lua_objlen(L, -1) == 0\n</code></pre>"},{"location":"reference.html#lua_newtable","title":"<code>lua_newtable</code>","text":"<p><code>void lua_newtable(lua_State* L)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Pushes a new table onto the stack. This is equivalent to <code>lua_createtable(L, 0, 0)</code>.</p>"},{"location":"reference.html#get-functions","title":"Get Functions","text":""},{"location":"reference.html#lua_gettable","title":"<code>lua_gettable</code>","text":"<p><code>int lua_gettable(lua_State* L, int idx)</code> <code>[-1, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Pushes a value from a table onto the stack. The table is at index <code>idx</code> on the stack, and the key into the table is on the top of the stack. This function pops the key at the top of the stack. The <code>__index</code> metamethod may be triggered when using this function.  If this is undesirable, use <code>lua_rawget</code> instead.</p> <p>Returns the type of the value.</p> Example<pre><code>// Assume the top of the stack is the Luau table: { \"hello\" = 40 }\nlua_pushliteral(L, \"hello\");\nint t = lua_gettable(L, -2); // Our key \"hello\" is at the top of the stack, and -2 is the table.\n// t == LUA_TNUMBER\n// lua_tonumber(L, -1) == 40\n</code></pre>"},{"location":"reference.html#lua_getfield","title":"<code>lua_getfield</code>","text":"<p><code>int lua_getfield(lua_State* L, int idx, const char* k)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>k</code>: Field</li> </ul> <p>Pushes a value from a table onto the stack. The table is at index <code>idx</code> on the stack, and the key into the table is <code>k</code>. The <code>__index</code> metamethod may be triggered when using this function. If this is undesirable, use <code>lua_rawgetfield</code> instead.</p> <p>Returns the type of the value.</p> Example<pre><code>// Assume the top of the stack is the Luau table: { \"hello\" = 40 }\nint t = lua_getfield(L, -2, \"hello\"); // Our key \"hello\" is at the top of the stack, and -2 is the table.\n// t == LUA_TNUMBER\n// lua_tonumber(L, -1) == 40\n</code></pre>"},{"location":"reference.html#lua_getglobal","title":"<code>lua_getglobal</code>","text":"<p><code>int lua_getglobal(lua_State* L, const char* k)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>k</code>: Field</li> </ul> <p>Pushes a value from the global table onto the stack. Use <code>lua_setglobal</code> to set a new global value.</p> <p>Returns the type of the value.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_setglobal(L, \"message\"); // _G.message = \"hello\"\n\nlua_getglobal(L, \"message\");\nconst char* s = lua_tostring(L, -1); // s == \"hello\"\n</code></pre>"},{"location":"reference.html#lua_rawgetfield","title":"<code>lua_rawgetfield</code>","text":"<p><code>int lua_rawgetfield(lua_State* L, int idx, const char* k)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>k</code>: Field</li> </ul> <p>This is the same as <code>lua_getfield</code>, except no <code>__index</code> metamethod is ever called.</p>"},{"location":"reference.html#lua_rawget","title":"<code>lua_rawget</code>","text":"<p><code>int lua_rawget(lua_State* L, int idx)</code> <code>[-1, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>This is the same as <code>lua_gettable</code>, except no <code>__index</code> metamethod is ever called.</p>"},{"location":"reference.html#lua_rawgeti","title":"<code>lua_rawgeti</code>","text":"<p><code>int lua_rawgeti(lua_State* L, int idx, int n)</code> <code>[-1, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>n</code>: Table index</li> </ul> <p>Pushes the table value at index <code>n</code> onto the stack. The table is located on the stack at <code>idx</code>. Similar to <code>lua_rawget</code>, no metamethods are called. Note that Luau tables start at index <code>1</code>, not <code>0</code>.</p> Example<pre><code>// Assume the top of the stack is the Luau table: { 5, 15, 30 }\nlua_rawgeti(L, -1, 2); // t[2]\ndouble n = lua_tonumber(L, -1);\nprintf(\"%f\\n\", n); // 15\n</code></pre>"},{"location":"reference.html#lua_setreadonly","title":"<code>lua_setreadonly</code>","text":"<p><code>void lua_setreadonly(lua_State* L, int idx, int enabled)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>enabled</code>: Readonly enabled</li> </ul> <p>Sets the read-only state of a table. Read-only tables ensure that table values cannot be modified, added, or removed. This is only a shallow application, i.e. a nested table may still be writable.</p> Example<pre><code>lua_newtable(L);\nlua_pushliteral(L, \"hello\");\nlua_rawsetfield(L, -2, \"message\"); // t.message = \"hello\"\nlua_setreadonly(L, -1, true);\n</code></pre>"},{"location":"reference.html#lua_getreadonly","title":"<code>lua_getreadonly</code>","text":"<p><code>int lua_getreadonly(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the table is marked as read-only, otherwise <code>0</code>.</p> Example<pre><code>// Assume a table is at the top of the stack\nif (!lua_getreadonly(L, -1)) {\n    // Safe to modify table\n}\n</code></pre>"},{"location":"reference.html#lua_setsafeenv","title":"<code>lua_setsafeenv</code>","text":"<p><code>void lua_setsafeenv(lua_State* L, int idx, int enabled)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>enabled</code>: Safe environment enabled</li> </ul> <p>Sets the safe-env state of a thread. TODO.</p>"},{"location":"reference.html#lua_getsafeenv","title":"<code>lua_getsafeenv</code>","text":"<p><code>int lua_getsafeenv(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Gets the safe-env state of a thread. TODO.</p>"},{"location":"reference.html#set-functions","title":"Set Functions","text":""},{"location":"reference.html#lua_settable","title":"<code>lua_settable</code>","text":"<p><code>void lua_settable(lua_State* L, int idx)</code> <code>[-2, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Sets the value of a table index, e.g. <code>t[k] = v</code>, where <code>t</code> is located on the stack at <code>idx</code>, and the key and value are on the top of the stack.</p> Example<pre><code>lua_newtable(L);\n\nlua_pushliteral(L, \"hello\");\nlua_pushinteger(L, 50);\nlua_settable(L, -3); // t.hello = 50\n</code></pre>"},{"location":"reference.html#lua_setfield","title":"<code>lua_setfield</code>","text":"<p><code>void lua_setfield(lua_State* L, int idx, const char* k)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>k</code>: Field</li> </ul> <p>Sets the value of a table index, e.g. <code>t[k] = v</code>, where <code>t</code> is located on the stack at <code>idx</code>, and the value is on the top of the stack.</p> Example<pre><code>lua_newtable(L);\n\nlua_pushinteger(L, 50);\nlua_setfield(L, -2, \"hello\"); // t.hello = 50\n</code></pre>"},{"location":"reference.html#lua_setglobal","title":"<code>lua_setglobal</code>","text":"<p><code>void lua_setglobal(lua_State* L, const char* k)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>k</code>: Field</li> </ul> <p>Places the value at the top of the stack into the global table at key <code>k</code>. The value is popped from the stack. Use <code>lua_getglobal</code> to retrieve the value.</p> <p>As implied by the name, globals are globally-accessible to Luau.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_setglobal(L, \"message\"); // _G.message = \"hello\"\n</code></pre> Luau Example<pre><code>print(message) -- \"hello\"\n</code></pre>"},{"location":"reference.html#lua_rawsetfield","title":"<code>lua_rawsetfield</code>","text":"<p><code>void lua_rawsetfield(lua_State* L, int idx, const char* k)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>k</code>: Field</li> </ul> <p>The same as <code>lua_setfield</code>, except no metamethods are invoked.</p>"},{"location":"reference.html#lua_rawset","title":"<code>lua_rawset</code>","text":"<p><code>void lua_rawset(lua_State* L, int idx)</code> <code>[-2, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>The same as <code>lua_settable</code>, except no metamethods are invoked.</p>"},{"location":"reference.html#lua_rawseti","title":"<code>lua_rawseti</code>","text":"<p><code>int lua_rawseti(lua_State* L, int idx, int n)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>n</code>: Table index</li> </ul> <p>Performs <code>t[n] = v</code>, where <code>t</code> is the table on the stack at <code>idx</code>, and <code>v</code> is the value on the top of the stack. The top value is also popped.</p> Example<pre><code>lua_newtable(L);\n\nfor (int i = 1; i &lt;= 10; i++) {\n    lua_pushinteger(L, i * 10);\n    lua_rawseti(L, -2, i); // t[i] = i * 10\n}\n</code></pre>"},{"location":"reference.html#lua_setfenv","title":"<code>lua_setfenv</code>","text":"<p><code>int lua_setfenv(lua_State* L, int idx)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Sets the environment of the value at <code>idx</code> to the table on the top of the stack, and pops this top value. Returns <code>0</code> if the value at the given index is not an applicable type for setting an environment (e.g. a number), otherwise returns <code>1</code>.</p>"},{"location":"reference.html#string-functions","title":"String Functions","text":""},{"location":"reference.html#lua_pushliteral","title":"<code>lua_pushliteral</code>","text":"<p><code>void lua_pushliteral(lua_State* L, const char* str)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>str</code>: C-style string</li> </ul> <p>Pushes the string literal <code>str</code> to the stack with a length of <code>len</code>.</p> Example<pre><code>lua_pushliteral(L, \"hello world\");\n</code></pre>"},{"location":"reference.html#lua_pushlstring","title":"<code>lua_pushlstring</code>","text":"<p><code>void lua_pushlstring(lua_State* L, const char* str, size_t len)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>str</code>: C-style string</li> <li><code>len</code>: String length</li> </ul> <p>Pushes string <code>str</code> to the stack with a length of <code>len</code>.</p> <p>Internally, strings in Luau are copied and interned. Thus, modifications made to the inputted string will not be reflected in the Luau string value.</p> <p>This function is preferred over <code>lua_pushstring</code> if the string length is known, or if the string contains <code>\\0</code> characters as part of the string itself.</p> Example<pre><code>std::string str = \"hello\";\nlua_pushlstring(L, str.c_str(), str.size());\n</code></pre>"},{"location":"reference.html#lua_pushstring","title":"<code>lua_pushstring</code>","text":"<p><code>void lua_pushstring(lua_State* L, const char* str)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>str</code>: C-style string</li> </ul> <p>Pushes string <code>str</code> to the stack. The length of the string is determined internally using the C <code>strlen</code> function.</p> <p>If the length of the string is known, it is more efficient to use <code>lua_pushlstring</code>.</p> <p>Internally, strings in Luau are copied and interned. Thus, modifications made to the inputted string will not be reflected in the Luau string value.</p> Example<pre><code>const char* str = \"hello\";\nlua_pushstring(L, str);\n</code></pre>"},{"location":"reference.html#lua_pushvfstring","title":"<code>lua_pushvfstring</code>","text":"<p><code>const char* lua_pushvfstring(lua_State* L, const char* fmt, va_list argp)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fmt</code>: C-style string for formatting</li> <li><code>argp</code>: Format arguments</li> </ul> <p>Pushes a string to the stack, where the string is <code>fmt</code> formatted against the arguments in <code>argp</code>. The formatted string is also returned.</p> Example<pre><code>void format_something(lua_State* L, const char* fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    lua_pushvfstring(L, fmt, args);\n    va_end(args);\n}\n\nformat_something(L, \"number: %d\", 32);\n</code></pre>"},{"location":"reference.html#lua_pushfstring","title":"<code>lua_pushfstring</code>","text":"<p><code>const char* lua_pushfstring(lua_State* L, const char* fmt,  ...)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fmt</code>: C-style string for formatting</li> <li><code>...</code>: Format arguments</li> </ul> <p>Pushes a string to the stack, where the string is <code>fmt</code> formatted against the arguments. The formatted string is also returned.</p> Example<pre><code>const char* s = lua_pushfstring(L, \"number: %d\", 32);\n</code></pre>"},{"location":"reference.html#lua_tolstring","title":"<code>lua_tolstring</code>","text":"<p><code>const char* lua_tolstring(lua_State* L, int idx, size_t len)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>len</code>: String length</li> </ul> <p>Returns the value at the given stack index converted to a string. The length of the string is written to <code>len</code>. Like C strings, Luau strings are terminated with <code>\\0</code>; however, Luau strings may contain <code>\\0</code> within the string before the end, thus using the <code>len</code> argument is imperative for proper consumption. In other words, functions like <code>strlen</code> that scan for <code>\\0</code> may return lengths that are too short.</p> <p>Note: This will modify the value at the given stack index if it is a number, turning it into a Luau string. If the value at the given stack index is neither a string nor a number, this function will return <code>NULL</code>, and the <code>len</code> argument will be set to <code>0</code>.</p> Example 1<pre><code>lua_pushliteral(L, \"hello world\");\n\nsize_t len;\nconst char* msg = lua_tolstring(L, -1, &amp;len);\n\nif (msg) {\n    printf(\"message (len: %zu): \\\"%s\\\"\\n\", len, msg); // message (len: 11) \"hello world\"\n}\n</code></pre> <p>As noted above, <code>lua_tolstring</code> will convert numbers into strings at their given stack index. If this effect is undesirable, either use <code>lua_isstring()</code> first, or use the auxilery <code>luaL_tolstring</code> function instead. Example 2<pre><code>lua_pushinteger(L, 15);\n\n// The value at index -1 will be converted from a number to a string:\nsize_t len;\nconst char* msg = lua_tolstring(L, -1, &amp;len);\n\nprintf(\"Type: %s\\n\", luaL_typename(L, -1)); // Type: string\n</code></pre></p>"},{"location":"reference.html#lua_tostring","title":"<code>lua_tostring</code>","text":"<p><code>const char* lua_tostring(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Equivalent to <code>lua_tolstring</code>, without the length argument.</p>"},{"location":"reference.html#lua_tostringatom","title":"<code>lua_tostringatom</code>","text":"<p><code>const char* lua_tostringatom(lua_State* L, int idx, int* atom)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>atom</code>: Atom</li> </ul> <p>Identical to <code>lua_tostring</code>, except the string atom is written to the <code>atom</code> argument. See the Atoms page for more information on string atoms.</p>"},{"location":"reference.html#lua_tolstringatom","title":"<code>lua_tolstringatom</code>","text":"<p><code>const char* lua_tolstringatom(lua_State* L, int idx, size_t len, int* atom)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>len</code>: String length</li> <li><code>atom</code>: Atom</li> </ul> <p>Identical to <code>lua_tolstring</code>, except the string atom is written to the <code>atom</code> argument. See the Atoms page for more information on string atoms.</p>"},{"location":"reference.html#lua_strlen","title":"<code>lua_strlen</code>","text":"<p><code>int lua_strlen(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Alias for <code>lua_objlen</code>.</p>"},{"location":"reference.html#lua_isstring","title":"<code>lua_isstring</code>","text":"<p><code>int lua_isstring(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at the given stack index is a string or a number (all numbers can be converted to a string). Otherwise, returns <code>0</code>.</p>"},{"location":"reference.html#lual_tolstring","title":"<code>luaL_tolstring</code>","text":"<p><code>const char* luaL_tolstring(lua_State* L, int idx, size_t len)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>len</code>: String length</li> </ul> <p>Converts the value at the given index into a string. This string is both pushed onto the stack and returned. Unlike <code>lua_tolstring</code> and <code>lua_tostring</code>, this function does not modify the value at the given stack index.</p> Example<pre><code>lua_pushvector(L, 10, 20, 30);\nconst char* vstr = lua_tolstring(L, -1, nullptr);\nlua_pop(L, 1); // pop vstr from the stack\nprintf(\"vector: %s\\n\", vstr); // \"vector: 10, 20, 30\"\n</code></pre>"},{"location":"reference.html#lual_checklstring","title":"<code>luaL_checklstring</code>","text":"<p><code>const char* luaL_checklstring(lua_State* L, int idx, size_t len)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>len</code>: String length</li> </ul> <p>Similar to <code>lua_tolstring</code>, except the type will be asserted. If the value is not a string, an error will be thrown.</p> Example<pre><code>int send_message(lua_State* L) {\n    size_t message_len;\n    const char* message = luaL_checklstring(L, 1, &amp;message_len);\n}\n</code></pre>"},{"location":"reference.html#lual_checkstring","title":"<code>luaL_checkstring</code>","text":"<p><code>const char* luaL_checkstring(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Equivalent to <code>luaL_checklstring(L, idx, nullptr)</code>.</p>"},{"location":"reference.html#lual_optlstring","title":"<code>luaL_optlstring</code>","text":"<p><code>const char* luaL_optlstring(lua_State* L, int idx, const char* def, size_t len)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default string</li> <li><code>len</code>: String length</li> </ul> <p>Gets the string at the given stack index. If the value at the given index is nil or none, then <code>def</code> is returned instead. Otherwise, an error is thrown.</p> Example<pre><code>int send_message(lua_State* L) {\n    size_t message_len;\n    const char* message = luaL_optlstring(L, 1, \"Default message\", &amp;message_len);\n}\n</code></pre>"},{"location":"reference.html#lual_optstring","title":"<code>luaL_optstring</code>","text":"<p><code>const char* luaL_optstring(lua_State* L, int idx, const char* def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default string</li> </ul> <p>Equivalent to <code>luaL_optlstring(L, idx, def, nullptr)</code>.</p>"},{"location":"reference.html#number-functions","title":"Number Functions","text":""},{"location":"reference.html#lua_pushnumber","title":"<code>lua_pushnumber</code>","text":"<p><code>void lua_pushnumber(lua_State* L, double n)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>n</code>: Number</li> </ul> <p>Pushes <code>n</code> to the stack.</p> Example<pre><code>lua_pushnumber(L, 15.2);\n</code></pre>"},{"location":"reference.html#lua_pushinteger","title":"<code>lua_pushinteger</code>","text":"<p><code>void lua_pushinteger(lua_State* L, int n)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>n</code>: Number</li> </ul> <p>Pushes <code>n</code> to the stack. Note that all Luau numbers are doubles, so the value of <code>n</code> will be cast to a <code>double</code>.</p> Example<pre><code>lua_pushinteger(L, 32);\n</code></pre>"},{"location":"reference.html#lua_pushunsigned","title":"<code>lua_pushunsigned</code>","text":"<p><code>void lua_pushunsigned(lua_State* L, unsigned int n)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>n</code>: Number</li> </ul> <p>Pushes <code>n</code> to the stack. Note that all Luau numbers are doubles, so the value of <code>n</code> will be cast to a <code>double</code>.</p> Example<pre><code>lua_pushunsigned(L, 32);\n</code></pre>"},{"location":"reference.html#lua_tonumberx","title":"<code>lua_tonumberx</code>","text":"<p><code>double lua_tonumberx(lua_State* L, int idx, int* isnum)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>isnum</code>: Is number</li> </ul> <p>Returns the number at the given stack index. If the value on the stack is a string, Luau will attempt to convert the string to a number.</p> <p>If the value is a number, or successfully converted to a number, the <code>isnum</code> argument will be set to <code>1</code>, otherwise <code>0</code>.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_pushliteral(L, \"12.5\");\nlua_pushnumber(L, 15);\n\ndouble n;\nint isnum;\n\n// isnum will be false, since \"hello\" cannot be converted to a number:\nn = lua_tonumberx(L, -3, &amp;isnum);\nif (isnum) {\n    printf(\"n: %f\\n\", n);\n}\n\n// isnum is true, and \"12.5\" is converted to 12.5:\nn = lua_tonumberx(L, -2, &amp;isnum);\nif (isnum) {\n    printf(\"n: %f\\n\", n);\n}\n\n// isnum is true, and the value is 15:\nn = lua_tonumberx(L, -1, &amp;isnum);\nif (isnum) {\n    printf(\"n: %f\\n\", n);\n}\n</code></pre>"},{"location":"reference.html#lua_tonumber","title":"<code>lua_tonumber</code>","text":"<p><code>double lua_tonumber(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number at the given stack index. If the value on the stack is a string, Luau will attempt to convert the string to a number. Identical to <code>lua_tonumberx</code>, without the last <code>isnum</code> argument.</p>"},{"location":"reference.html#lua_tointegerx","title":"<code>lua_tointegerx</code>","text":"<p><code>int lua_tointegerx(lua_State* L, int idx, int* isnum)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>isnum</code>: Is number</li> </ul> <p>Returns the number at the given stack index as an integer. If the value on the stack is a string, Luau will attempt to convert the string to an integer. Numbers in Luau are all doubles, so the returned value is cast to an int.</p> <p>If the value is a number, or successfully converted to a number, the <code>isnum</code> argument will be set to <code>1</code>, otherwise <code>0</code>.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_pushliteral(L, \"12.5\");\nlua_pushinteger(L, 15);\n\nint n;\nint isnum;\n\n// isnum will be false, since \"hello\" cannot be converted to a number:\nn = lua_tointegerx(L, -3, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n\n// isnum is true, and \"12.5\" is converted to 12:\nn = lua_tointegerx(L, -2, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n\n// isnum is true, and the value is 15:\nn = lua_tointegerx(L, -1, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n</code></pre>"},{"location":"reference.html#lua_tointeger","title":"<code>lua_tointeger</code>","text":"<p><code>int lua_tointeger(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number at the given stack index as an integer. If the value on the stack is a string, Luau will attempt to convert the string to an integer. Numbers in Luau are all doubles, so the returned value is cast to an int. Identical to <code>lua_tointegerx</code>, without the last <code>isnum</code> argument.</p>"},{"location":"reference.html#lua_tounsignedx","title":"<code>lua_tounsignedx</code>","text":"<p><code>unsigned lua_tounsignedx(lua_State* L, int idx, int* isnum)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>isnum</code>: Is number</li> </ul> <p>Returns the number at the given stack index as an unsigned integer. If the value on the stack is a string, Luau will attempt to convert the string to an integer. Numbers in Luau are all doubles, so the returned value is cast to an unsigned int.</p> <p>If the value is a number, or successfully converted to a number, the <code>isnum</code> argument will be set to <code>1</code>, otherwise <code>0</code>.</p> Example<pre><code>lua_pushliteral(L, \"hello\");\nlua_pushliteral(L, \"12.5\");\nlua_pushunsigned(L, 15);\n\nunsigned n;\nint isnum;\n\n// isnum will be false, since \"hello\" cannot be converted to a number:\nn = lua_tounsignedx(L, -3, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n\n// isnum is true, and \"12.5\" is converted to 12:\nn = lua_tounsignedx(L, -2, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n\n// isnum is true, and the value is 15:\nn = lua_tounsignedx(L, -1, &amp;isnum);\nif (isnum) {\n    printf(\"n: %d\\n\", n);\n}\n</code></pre>"},{"location":"reference.html#lua_tounsigned","title":"<code>lua_tounsigned</code>","text":"<p><code>unsigned lua_tounsigned(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number at the given stack index as an unsigned integer. If the value on the stack is a string, Luau will attempt to convert the string to an integer. Numbers in Luau are all doubles, so the returned value is cast to an unsigned int. Identical to <code>lua_tounsignedx</code>, without the last <code>isnum</code> argument.</p>"},{"location":"reference.html#lua_isnumber","title":"<code>lua_isnumber</code>","text":"<p><code>int lua_isnumber(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at stack index <code>idx</code> is a number or the value is a string that can be coerced to a number. Otherwise, returns <code>0</code>.</p>"},{"location":"reference.html#lual_checknumber","title":"<code>luaL_checknumber</code>","text":"<p><code>double luaL_checknumber(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number at the given stack index. If the value is not a number, an error is thrown.</p> Example<pre><code>int add(lua_State* L) {\n    double lhs = luaL_checknumber(L, 1);\n    double rhs = luaL_checknumber(L, 2);\n\n    lua_pushnumber(L, lhs + rhs);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lual_checkinteger","title":"<code>luaL_checkinteger</code>","text":"<p><code>int luaL_checkinteger(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number (cast to <code>int</code>) at the given stack index. If the value is not a number, an error is thrown.</p> Example<pre><code>int add_int(lua_State* L) {\n    int lhs = luaL_checkinteger(L, 1);\n    int rhs = luaL_checkinteger(L, 2);\n\n    lua_pushinteger(L, lhs + rhs);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lual_checkunsigned","title":"<code>luaL_checkunsigned</code>","text":"<p><code>unsigned luaL_checkunsigned(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the number (cast to <code>unsigned</code>) at the given stack index. If the value is not a number, an error is thrown.</p> Example<pre><code>int add_int(lua_State* L) {\n    unsigned lhs = luaL_checkunsigned(L, 1);\n    unsigned rhs = luaL_checkunsigned(L, 2);\n\n    lua_pushunsigned(L, lhs + rhs);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lual_optnumber","title":"<code>luaL_optnumber</code>","text":"<p><code>double luaL_optnumber(lua_State* L, int idx, double def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default</li> </ul> <p>Returns the number at the given stack index, or the default number if the value at the stack index is nil or none. Otherwise, an error is thrown.</p> Example<pre><code>int approx_equal(lua_State* L) {\n    double a = luaL_checknumber(L, 1);\n    double b = luaL_checknumber(L, 2);\n\n    double epsilon = luaL_optnumber(L, 3, 0.00001);\n\n    lua_pushboolean(L, fabs(a - b) &lt; epsilon);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lual_optinteger","title":"<code>luaL_optinteger</code>","text":"<p><code>int luaL_optinteger(lua_State* L, int idx, int def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default</li> </ul> <p>Returns the number (cast to <code>int</code>) at the given stack index, or the default number if the value at the stack index is nil or none. Otherwise, an error is thrown.</p>"},{"location":"reference.html#lual_optunsigned","title":"<code>luaL_optunsigned</code>","text":"<p><code>unsigned luaL_optunsigned(lua_State* L, int idx, unsigned def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default</li> </ul> <p>Returns the number (cast to <code>unsigned</code>) at the given stack index, or the default number if the value at the stack index is nil or none. Otherwise, an error is thrown.</p>"},{"location":"reference.html#boolean-functions","title":"Boolean Functions","text":""},{"location":"reference.html#lua_pushboolean","title":"<code>lua_pushboolean</code>","text":"<p><code>void lua_pushboolean(lua_State* L, int b)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>b</code>: Boolean</li> </ul> <p>Pushes boolean <code>b</code> to the stack.</p> Example<pre><code>lua_pushboolean(L, true);\nlua_pushboolean(L, false);\n</code></pre>"},{"location":"reference.html#lua_toboolean","title":"<code>lua_toboolean</code>","text":"<p><code>int lua_toboolean(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the Luau value at the given stack index is truthy, otherwise returns <code>0</code>.</p> <p>A \"falsey\" value in Luau is any value that is either <code>nil</code> or <code>false</code>. All other values are evaluated as <code>true</code>. In other languages, values like <code>0</code> or empty strings might be evaluated as <code>false</code>. This is not the case in Luau. Only <code>nil</code> and <code>false</code> are evaluated as <code>false</code>; all other values are evaluated as <code>true</code>.</p> Example<pre><code>lua_pushboolean(L, true);\nlua_pushboolean(L, false);\nlua_pushnil(L);\nlua_pushinteger(L, 0);\n\nif (lua_toboolean(L, -4)) {} // true\nif (lua_toboolean(L, -3)) {} // false\nif (lua_toboolean(L, -2)) {} // false (nil is evaluated as false)\nif (lua_toboolean(L, -1)) {} // true (0 is neither nil or false, so it is evaluated as true in Luau)\n</code></pre>"},{"location":"reference.html#lua_isboolean","title":"<code>lua_isboolean</code>","text":"<p><code>int lua_isboolean(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a boolean.</p> Example<pre><code>if (lua_isboolean(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lual_checkboolean","title":"<code>luaL_checkboolean</code>","text":"<p><code>int luaL_checkboolean(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the Luau value at the given stack index is true, otherwise returns <code>0</code>. Throws an error if the value at the given index is not a boolean.</p> <p>Note: Unlike <code>lua_toboolean</code>, this is not a truthy/falsey check. The value at the given index must be a boolean.</p>"},{"location":"reference.html#lual_optboolean","title":"<code>luaL_optboolean</code>","text":"<p><code>int luaL_optboolean(lua_State* L, int idx, int def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default</li> </ul> <p>Returns <code>1</code> or <code>0</code> for the given boolean value. Returns <code>def</code> if the value at the given index is nil or none. Otherwise, an error is thrown.</p> <p>Note: Unlike <code>lua_toboolean</code>, this is not a truthy/falsey check. The value at the given index must be a boolean.</p>"},{"location":"reference.html#vector-functions","title":"Vector Functions","text":""},{"location":"reference.html#lua_pushvector","title":"<code>lua_pushvector</code>","text":"<p><code>void lua_pushvector(lua_State* L, float x, float y, float z)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>x</code>: X</li> <li><code>y</code>: Y</li> <li><code>z</code>: Z</li> </ul> <p>Pushes a vector to the Luau stack. Luau comes with a vector library for operating against vector values.</p> <p>Note: Unlike Luau numbers being double-precision floating point numbers, Luau vector values are single-precision floats.</p> Example 3-wide<pre><code>// By default, Luau vectors are 3-wide\n\nlua_pushvector(L, 10, 15, 20);\n\nconst char* v = lua_tovector(L, -1);\nfloat x = v[0]; // 10\nfloat y = v[1]; // 15\nfloat z = v[2]; // 20\n</code></pre> <p>If Luau is built with the <code>LUA_VECTOR_SIZE</code> preprocessor set to <code>4</code>, then this will be a 4-wide vector, and the function will have an additional <code>w</code> parameter. Example 4-wide<pre><code>// If Luau is built with LUA_VECTOR_SIZE=4\n\nlua_pushvector(L, 10, 15, 20, 25);\n\nconst char* v = lua_tovector(L, -1);\nfloat x = v[0]; // 10\nfloat y = v[1]; // 15\nfloat z = v[2]; // 20\nfloat w = v[3]; // 25\n</code></pre></p>"},{"location":"reference.html#lua_tovector","title":"<code>lua_tovector</code>","text":"<p><code>const float* lua_tovector(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the vector at the given Luau index, or <code>NULL</code> if not a vector.</p> <p>By default, vectors in Luau are 3-wide. Luau can be built with the <code>LUA_VECTOR_SIZE</code> preprocessor set to <code>4</code> for 4-wide vectors.</p> Example<pre><code>lua_pushvector(L, 3, 5, 2); // x, y, z\n\nconst float* vec = lua_tovector(L, -1);\n\nfloat x = vec[0];\nfloat y = vec[1];\nfloat z = vec[2];\nprintf(\"%f, %f, %f\\n\", x, y, z);\n</code></pre>"},{"location":"reference.html#lua_isvector","title":"<code>lua_isvector</code>","text":"<p><code>int lua_isvector(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a vector.</p> Example<pre><code>if (lua_isvector(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lual_checkvector","title":"<code>luaL_checkvector</code>","text":"<p><code>const float* luaL_checkvector(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the vector at the given Luau index. If the value at the given index is not a vector, an error is thrown.</p>"},{"location":"reference.html#lual_optvector","title":"<code>luaL_optvector</code>","text":"<p><code>const float* luaL_optvector(lua_State* L, int idx, const float* def)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default</li> </ul> <p>Returns the vector at the given Luau index. If the value at the given index is nil or none, then <code>def</code> is returned. Otherwise, an error is thrown.</p>"},{"location":"reference.html#buffer-functions","title":"Buffer Functions","text":""},{"location":"reference.html#lua_newbuffer","title":"<code>lua_newbuffer</code>","text":"<p><code>void* lua_newbuffer(lua_State* L, size_t sz)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>sz</code>: Size</li> </ul> <p>Pushes a new buffer to the stack and returns a pointer to the buffer. Buffers are just arbitrary data. Luau can create and interact with buffers through the <code>buffer</code> library. Use the <code>lua_tobuffer</code> function to retrieve a buffer from the stack.</p> Example<pre><code>struct Foo {\n    int n;\n}\n\n// As an example, write 'Foo' to a buffer:\nFoo foo{};\nfoo.n = 10;\nvoid* buf = lua_newbuffer(L, sizeof(Foo));\nmemcpy(buf, &amp;foo, sizeof(Foo));\n</code></pre>"},{"location":"reference.html#lua_tobuffer","title":"<code>lua_tobuffer</code>","text":"<p><code>void* lua_tobuffer(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the buffer at the given stack index, or <code>NULL</code> if the value is not a buffer.</p> Example<pre><code>void* buf = lua_newbuffer(L, 10);\n\nsize_t len;\nvoid* b = lua_tobuffer(L, -1, &amp;len);\n// b == buf\n// len == 10\n</code></pre>"},{"location":"reference.html#lua_isbuffer","title":"<code>lua_isbuffer</code>","text":"<p><code>int lua_isbuffer(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a buffer.</p> Example<pre><code>if (lua_isbuffer(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lual_checkbuffer","title":"<code>luaL_checkbuffer</code>","text":"<p><code>void* luaL_checkbuffer(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the buffer at the given stack index. If the value retrieved is not a buffer, an error is thrown.</p>"},{"location":"reference.html#metatable-functions","title":"Metatable Functions","text":""},{"location":"reference.html#lua_setmetatable","title":"<code>lua_setmetatable</code>","text":"<p><code>int lua_setmetatable(lua_State* L, int idx)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Takes the table at the top of the stack and assigns it as the metatable of the table on the stack at <code>idx</code>.</p> <p>The return value can be ignored; this function always returns <code>1</code>.</p> Example<pre><code>// Create table:\nlua_newtable(L); // t\n\n// Create metatable:\nlua_newtable(L); // mt\nlua_pushliteral(\"v\");\nlua_rawsetfield(L, -2, \"__mode\"); // mt.__mode = \"v\"\nlua_setmetatable(L, -2); // setmetatable(t, mt)\n</code></pre>"},{"location":"reference.html#lua_getmetatable","title":"<code>lua_getmetatable</code>","text":"<p><code>int lua_getmetatable(lua_State* L, int idx)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Gets the metatable for the object at the given stack index. If the metatable is found, it is pushed to the top of the stack and the function returns <code>1</code>. Otherwise, the function returns <code>0</code> and the stack remains the same.</p> Example<pre><code>if (lua_getmetatable(L, -1)) {\n    // Metatable is now at the top of the stack\n}\n</code></pre>"},{"location":"reference.html#lua_setuserdatametatable","title":"<code>lua_setuserdatametatable</code>","text":"<p><code>void lua_setuserdatametatable(lua_State* L, int tag)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> </ul> <p>Pops the value (expecting a table) at the top of the stack and sets the userdata metatable for the given userdata tag. This is used in conjunction with <code>lua_newuserdatataggedwithmetatable</code>. See the example there.</p> <p>This function can only be called once per tag. Calling this function again for the same tag will throw an error.</p>"},{"location":"reference.html#lua_getuserdatametatable","title":"<code>lua_getuserdatametatable</code>","text":"<p><code>void lua_getuserdatametatable(lua_State* L, int tag)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> </ul> <p>Pushes the metatable associated with the userdata tag onto the stack (or <code>nil</code> if there is no associated metatable).</p>"},{"location":"reference.html#lua_getmetafield","title":"<code>lua_getmetafield</code>","text":"<p><code>int lua_getmetafield(lua_State* L, int idx, const char* field)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>field</code>: Metatable field</li> </ul> <p>Attempts to get the given metatable field for the table at <code>idx</code>. If the table doesn't have a metatable, or the metatable doesn't have <code>field</code>, then this function returns <code>0</code> and nothing is pushed onto the stack. Otherwise, the function returns <code>1</code> and the field is pushed onto the stack.</p> Example<pre><code>// Assume the top of the stack is a table\n\nif (lua_getmetafield(L, -1, \"__index\")) {\n    // ...\n}\n</code></pre>"},{"location":"reference.html#lua_callmeta","title":"<code>lua_callmeta</code>","text":"<p><code>int lua_callmeta(lua_State* L, int idx, const char* field)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>field</code>: Metatable field</li> </ul> <p>Attempts to call the given metatable function for the table at <code>idx</code>. If the table doesn't have a metatable, or the metatable doesn't have <code>field</code>, then this function returns <code>0</code> and nothing is pushed onto the stack. Otherwise, the function returns <code>1</code> and the result of the called metatable function is pushed onto the stack.</p> Example<pre><code>// Assume the top of the stack is a table\n\nif (lua_callmeta(L, -1, \"__tostring\")) {\n    const char* result = lua_tostring(L, -1);\n    lua_pop(L, 1);\n    // ...\n}\n</code></pre>"},{"location":"reference.html#lual_newmetatable","title":"<code>luaL_newmetatable</code>","text":"<p><code>int luaL_newmetatable(lua_State* L, const char* name)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>name</code>: Name</li> </ul> <p>Creates (or fetches existing) metatable with a given name and pushes the metatable onto the stack. Returns <code>1</code> if the metatable was created, or <code>0</code> if the metatable aleady exists. This is useful for creating metatables linked to specific userdata types.</p> Example<pre><code>struct Foo {};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n\nif (luaL_newmetatable(L, \"Foo\")) {\n    // Build metatable:\n    lua_pushliteral(L, \"Foo\");\n    lua_rawsetfield(L, -2, \"__type\");\n}\nlua_setmetatable(L, -2);\n</code></pre>"},{"location":"reference.html#lual_getmetatable","title":"<code>luaL_getmetatable</code>","text":"<p><code>int luaL_getmetatable(lua_State* L, const char* name)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>name</code>: Name</li> </ul> <p>Attempts to get a metatable from the registry with the given name and pushes it to the stack. If no metatable is found, <code>nil</code> will be pushed to the stack. See <code>luaL_newmetatable</code>.</p> Example<pre><code>struct Foo {};\n\nFoo* new_Foo() {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n    if (luaL_newmetatable(L, \"Foo\")) {\n        // Build metatable:\n        lua_pushliteral(L, \"Foo\");\n        lua_rawsetfield(L, -2, \"__type\");\n    }\n    lua_setmetatable(L, -2);\n    return foo;\n}\n\n// ...\n\n// Get the metatable created with `luaL_newmetatable`:\nluaL_getmetatable(L, \"Foo\");\n</code></pre>"},{"location":"reference.html#userdata-functions","title":"Userdata Functions","text":""},{"location":"reference.html#lua_newuserdata","title":"<code>lua_newuserdata</code>","text":"<p><code>void* lua_newuserdata(lua_State* L, size_t sz)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>sz</code>: Size of the data</li> </ul> <p>Creates a userdata and pushes it to the stack. A pointer to the newly-constructed data is returned. This is equivalent to <code>lua_newuserdatatagged</code> with a tag of <code>0</code>.</p> <p>Note: Luau-constructed userdata are not zero-initialized. After construction, assign all fields of the object.</p> Example<pre><code>struct Foo {\n    int n;\n};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n\n// Before explicit assignment, `n` is garbage, so we should initialize it ourselves:\nfoo-&gt;n = 0;\n</code></pre>"},{"location":"reference.html#lua_newuserdatadtor","title":"<code>lua_newuserdatadtor</code>","text":"<p><code>void* lua_newuserdatadtor(lua_State* L, size_t sz, void (*dtor)(void*))</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>sz</code>: Size of the data</li> <li><code>dtor</code>: Destructor</li> </ul> <p>Creates a new userdata with an assigned destructor. Destructors are called when Luau is freeing up the userdata memory.</p> <p>To assign a destructor for all userdata of a given tag, use <code>lua_setuserdatadtor</code>.</p> Example<pre><code>struct Foo {\n    char* data;\n};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatadtor(L, sizeof(Foo), [](void* ptr) {\n    // This function is called when Foo is being GC'd. Free up any user-managed resources now.\n    Foo* f = static_cast&lt;Foo*&gt;(ptr);\n    delete[] f-&gt;data;\n}));\n\nfoo-&gt;data = new char[256];\n</code></pre>"},{"location":"reference.html#lua_newuserdatatagged","title":"<code>lua_newuserdatatagged</code>","text":"<p><code>void* lua_newuserdatatagged(lua_State* L, size_t sz, int tag)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>sz</code>: Size of the data</li> <li><code>tag</code>: Tag</li> </ul> <p>Creates the tagged userdata and pushes it to the stack. A pointer to the newly-constructed data is returned. Use <code>lua_touserdatatagged</code> to retrieve the value. For more info on tags, see the Tags page.</p> <p>Note: Luau-constructed userdata are not zero-initialized. After construction, assign all fields of the object.</p> Example<pre><code>constexpr int kFooTag = 1;\nstruct Foo {\n    int n;\n};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatatagged(L, sizeof(Foo), kFooTag));\n\n// Before explicit assignment, `n` is garbage, so we should initialize it ourselves:\nfoo-&gt;n = 0;\n</code></pre>"},{"location":"reference.html#lua_newuserdatataggedwithmetatable","title":"<code>lua_newuserdatataggedwithmetatable</code>","text":"<p><code>void* lua_newuserdatataggedwithmetatable(lua_State* L, size_t sz, int tag)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>sz</code>: Size of the data</li> <li><code>tag</code>: Tag</li> </ul> <p>Creates the tagged userdata with a pre-defined metatable and pushes it to the stack. A pointer to the newly-constructed data is returned. Use <code>lua_touserdatatagged</code> to retrieve the value. For more info on tags, see the Tags page.</p> <p>Using this method is faster than attempting to assign a metatable to new userdata every construction, e.g. using <code>luaL_newmetatable</code>. Instead, the metatable is created ahead of time using <code>lua_setuserdatametatable</code>, linked to the userdata's tag.</p> Example<pre><code>constexpr int kFooTag = 1;\n\nstruct Foo {\n    int n;\n};\n\nint Foo_index(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(luaL_touserdatatagged(L, 1, kFooTag));\n    const char* property = lua_tostring(L, 2);\n    if (property &amp;&amp; strcmp(property, \"n\") == 0) {\n        lua_pushinteger(L, foo-&gt;n);\n        return 1;\n    }\n    luaL_error(L, \"unknown property\");\n}\n\nint Foo_newindex(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(luaL_touserdatatagged(L, 1, kFooTag));\n    const char* property = lua_tostring(L, 2);\n    if (property &amp;&amp; strcmp(property, \"n\") == 0) {\n        int new_n = luaL_checkinteger(L, 3);\n        foo-&gt;n = new_n;\n        return 0;\n    }\n    luaL_error(L, \"unknown property\");\n}\n\nconst luaL_Reg Foo_metatable[] = {\n    {\"__index\", Foo_index},\n    {\"__newindex\", Foo_newindex},\n    {nullptr, nullptr},\n};\n\nint push_Foo() {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatataggedwithmetatable(L, sizeof(Foo), kFooTag));\n    foo-&gt;n = 0;\n    return 1;\n}\n\n// Called during some initialization period\nvoid setup() {\n    luaL_newmetatable(L, \"Foo\");\n    luaL_register(L, nullptr, Foo_metatable);\n    lua_setuserdatametatable(L, kFooTag);\n\n    lua_setglobal(\"new_foo\", push_Foo);\n}\n</code></pre> <pre><code>local foo = new_foo()\nfoo.n = 55\nprint(foo.n) -- 55\n</code></pre>"},{"location":"reference.html#lua_touserdata","title":"<code>lua_touserdata</code>","text":"<p><code>void* lua_touserdata(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns a pointer to a userdata on the stack. Returns <code>NULL</code> if the value is not a userdata.</p> <p>If it is preferred to throw an error if the value is not a userdata, use the <code>luaL_checkuserdata</code> function instead.</p> <p>Note: It may be unsafe to hang onto a pointer to a userdata value. The Luau GC owns the userdata memory, and may free it. See the page on pinning for tips on keeping a value from being GC'd, or consider using light userdata instead.</p> Example<pre><code>struct Foo {\n    int n;\n};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\nfoo-&gt;n = 32;\n\nFoo* f = static_cast&lt;Foo*&gt;(lua_touserdata(L, -1));\nprintf(\"foo-&gt;n = %d\\n\", foo-&gt;n); // foo-&gt;n = 32\n</code></pre>"},{"location":"reference.html#lua_touserdatatagged","title":"<code>lua_touserdatatagged</code>","text":"<p><code>void* lua_touserdatatagged(lua_State* L, int idx, int tag)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>tag</code>: Tag</li> </ul> <p>Returns a pointer to a tagged userdata on the stack. Returns <code>NULL</code> if the value is not a userdata or the userdata's tag does not match the provided <code>tag</code> argument. For more info on tags, see the Tags page.</p> <p>Note: It may be unsafe to hang onto a pointer to a userdata value. The Luau GC owns the userdata memory, and may free it. See the page on pinning for tips on keeping a value from being GC'd, or consider using light userdata instead.</p> Example<pre><code>constexpr int kFooTag = 1;\n\nstruct Foo {\n    int n;\n};\n\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatatagged(L, sizeof(Foo), kFooTag));\nfoo-&gt;n = 32;\n\nFoo* f = static_cast&lt;Foo*&gt;(lua_touserdatatagged(L, -1, kFooTag));\nprintf(\"foo-&gt;n = %d\\n\", foo-&gt;n); // foo-&gt;n = 32\n</code></pre>"},{"location":"reference.html#lua_setuserdatatag","title":"<code>lua_setuserdatatag</code>","text":"<p><code>int lua_setuserdatatag(lua_State* L, int idx, int tag)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>tag</code>: Tag</li> </ul> <p>Sets the tag for userdata at stack index <code>idx</code>. Alternatively, the <code>lua_newuserdatatagged</code> and <code>lua_newuserdatataggedwithmetatable</code> functions can be used to assign the tag on userdata creation.</p>"},{"location":"reference.html#lua_userdatatag","title":"<code>lua_userdatatag</code>","text":"<p><code>int lua_userdatatag(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the tag for the userdata at the given stack position. For non-userdata values, this function returns <code>-1</code>. If the userdata value was not assigned a tag, the tag will be set to the default of <code>0</code>, and thus this function will return <code>0</code>.</p> Example<pre><code>constexpr int kFooTag = 10;\nconstexpr int kBarTag = 20;\n\nstruct Foo {};\nstruct Bar {};\nstruct Baz {};\n\nlua_pushuserdatatagged(L, sizeof(Foo), kFooTag);\nlua_pushuserdatatagged(L, sizeof(Bar), kBarTag);\nlua_pushuserdata(L, sizeof(Baz));\n\nint foo_tag = lua_userdatatag(L, -3); // 10\nint bar_tag = lua_userdatatag(L, -2); // 20\nint baz_tag = lua_userdatatag(L, -1); // 0\n</code></pre>"},{"location":"reference.html#lua_setuserdatadtor","title":"<code>lua_setuserdatadtor</code>","text":"<p><code>int lua_setuserdatadtor(lua_State* L, int tag, lua_Destructor dtor)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> <li><code>dtor</code>: Tag</li> </ul> <p>Assigns the destructor function for a given userdata tag. All userdata with the given tag will utilize this destructor during GC.</p> Example<pre><code>constexpr int kFooTag = 10;\n\nstruct Foo {\n    char* some_allocated_data;\n};\n\nstatic void Foo_destructor(lua_State* L, void* data) {\n    Foo* foo = static_cast&lt;Foo*&gt;(data);\n    delete foo-&gt;some_allocated_data;\n}\n\nvoid setup_Foo(lua_State* L) {\n    luaL_newmetatable(L, \"Foo\");\n    // ...build metatable\n    lua_setuserdatametatable(L, kFooTag);\n\n    lua_setuserdatadtor(L, kFooTag, Foo_destructor);\n}\n</code></pre>"},{"location":"reference.html#lua_getuserdatadtor","title":"<code>lua_getuserdatadtor</code>","text":"<p><code>lua_Destructor lua_getuserdatadtor(lua_State* L, int tag)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> </ul> <p>Returns the destructor function assigned to the userdata tag.</p> Example<pre><code>constexpr int kFooTag = 10;\nstruct Foo {};\nstatic void Foo_destructor(lua_State* L, void* data) {}\n\nvoid setup_Foo(lua_State* L) {\n    // ...\n    auto dtor_before = lua_getuserdatadtor(L, kFooTag); // dtor_before == nullptr\n\n    lua_setuserdatadtor(L, kFooTag, Foo_destructor);\n\n    auto dtor_after = lua_getuserdatadtor(L, kFooTag); // dtor_after == Foo_destructor\n}\n</code></pre>"},{"location":"reference.html#lua_isuserdata","title":"<code>lua_isuserdata</code>","text":"<p><code>int lua_isuserdata(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns <code>1</code> if the value at the given stack index is a userdata object. Otherwise, returns <code>0</code>.</p>"},{"location":"reference.html#lual_checkudata","title":"<code>luaL_checkudata</code>","text":"<p><code>void* luaL_checkudata(lua_State* L, int ud, const char* name)</code> <code>[0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>ud</code>: Userdata index</li> <li><code>name</code>: Name</li> </ul> <p>Asserts that a value on the stack is a userdata with a matching metatable to <code>name</code> (created with <code>luaL_newmetatable</code>).</p> Example<pre><code>constexpr const char* kFoo = \"Foo\";\n\nstruct Foo { /* ... */ };\n\nFoo* check_Foo(lua_State* L, int idx) {\n    return static_cast&lt;Foo*&gt;(luaL_checkudata(L, kFoo));\n}\n</code></pre>"},{"location":"reference.html#light-userdata-functions","title":"Light Userdata Functions","text":""},{"location":"reference.html#lua_pushlightuserdata","title":"<code>lua_pushlightuserdata</code>","text":"<p><code>void lua_pushlightuserdata(lua_State* L, void* p)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>p</code>: Pointer to arbitrary user-owned data</li> </ul> <p>Pushes the tagged lightuserdata to the stack. Identical to <code>lua_pushlightuserdatatagged</code> with a tag of <code>0</code>.</p> Example<pre><code>struct Foo {};\nFoo* foo = new Foo();\n\nlua_pushlightuserdata(L, foo);\n</code></pre>"},{"location":"reference.html#lua_pushlightuserdatatagged","title":"<code>lua_pushlightuserdatatagged</code>","text":"<p><code>void lua_pushlightuserdatatagged(lua_State* L, void* p, int tag)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>p</code>: Pointer to arbitrary user-owned data</li> <li><code>tag</code>: Tag</li> </ul> <p>Pushes the tagged lightuserdata to the stack. Use <code>lua_tolightuserdatatagged</code> to retrieve the value. For more info on tags, see the Tags page.</p> Example<pre><code>constexpr int kFooTag = 1;\nstruct Foo {};\n\nFoo* foo = new Foo();\n\nlua_pushlightuserdatatagged(L, foo, kFooTag);\n</code></pre>"},{"location":"reference.html#lua_tolightuserdata","title":"<code>lua_tolightuserdata</code>","text":"<p><code>void* lua_tolightuserdata(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns a pointer to a lightuserdata on the stack. Returns <code>NULL</code> if the value is not a lightuserdata.</p> Example<pre><code>struct Foo {\n    int n;\n};\n\nFoo* foo = new Foo();\nfoo-&gt;n = 32;\n\nlua_pushlightuserdata(L, foo);\n\nFoo* f = static_cast&lt;Foo*&gt;(lua_tolightuserdata(L, -1));\nprintf(\"foo-&gt;n = %d\\n\", foo-&gt;n); // foo-&gt;n = 32\n\n// ...pop lightuserdata and delete allocation\n</code></pre>"},{"location":"reference.html#lua_tolightuserdatatagged","title":"<code>lua_tolightuserdatatagged</code>","text":"<p><code>void* lua_tolightuserdatatagged(lua_State* L, int idx, int tag)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>tag</code>: Tag</li> </ul> <p>Returns a pointer to a lightuserdata on the stack. Returns <code>NULL</code> if the value is not a lightuserdata or if the attached tag does not equal the provided <code>tag</code> argument. For more info on tags, see the Tags page.</p> Example<pre><code>constexpr int kFooTag = 1;\n\nstruct Foo {\n    int n;\n};\n\nFoo* foo = new Foo();\nfoo-&gt;n = 32;\n\nlua_pushlightuserdatatagged(L, foo, kFooTag);\n\nFoo* f = static_cast&lt;Foo*&gt;(lua_tolightuserdatatagged(L, -1, kFooTag));\nprintf(\"foo-&gt;n = %d\\n\", foo-&gt;n); // foo-&gt;n = 32\n\n// ...pop lightuserdata and delete allocation\n</code></pre>"},{"location":"reference.html#lua_islightuserdata","title":"<code>lua_islightuserdata</code>","text":"<p><code>int lua_islightuserdata(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a lightuserdata.</p> Example<pre><code>if (lua_islightuserdata(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_lightuserdatatag","title":"<code>lua_lightuserdatatag</code>","text":"<p><code>int lua_lightuserdatatag(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the tag for the lightuserdata at the given stack position. For non-lightuserdata values, this function returns <code>-1</code>. If the lightuserdata value was not assigned a tag, the tag will be set to the default of <code>0</code>, and thus this function will return <code>0</code>.</p> Example<pre><code>constexpr int kFooTag = 10;\nconstexpr int kBarTag = 20;\n\nstruct Foo {};\nstruct Bar {};\nstruct Baz {};\n\nFoo* foo = new Foo();\nlua_pushlightuserdatatagged(L, foo, kFooTag);\n\nBar* bar = new Bar();\nlua_pushlightuserdatatagged(L, bar, kBarTag);\n\nBaz* baz = new Baz();\nlua_pushlightuserdata(L, baz);\n\nint foo_tag = lua_lightuserdatatag(L, -3); // 10\nint bar_tag = lua_lightuserdatatag(L, -2); // 20\nint baz_tag = lua_lightuserdatatag(L, -1); // 0\n\n// ...pop lightuserdata and delete allocations\n</code></pre>"},{"location":"reference.html#lua_setlightuserdataname","title":"<code>lua_setlightuserdataname</code>","text":"<p><code>void lua_setlightuserdataname(lua_State* L, int tag, const char* name)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> <li><code>name</code>: Name</li> </ul> <p>Sets the name for the tagged lightuserdata. The string is copied, so the provided name argument is safe to dispose.</p> <p>Calling this function more than once for the same tag will throw an error.</p> Example<pre><code>constexpr int kMyDataTag = 10;\nlua_setlightuserdataname(L, kMyDataTag, \"MyData\");\n</code></pre>"},{"location":"reference.html#lua_getlightuserdataname","title":"<code>lua_getlightuserdataname</code>","text":"<p><code>const char* lua_getlightuserdataname(lua_State* L, int tag)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>tag</code>: Tag</li> </ul> <p>Returns the name for the tagged lightuserdata (or <code>nullptr</code> if no name is assigned).</p> Example<pre><code>constexpr int kMyDataTag = 10;\nlua_setlightuserdataname(L, kMyDataTag, \"MyData\");\nconst char* name = lua_getlightuserdataname(L, kMyDataTag); // name == \"MyData\"\n</code></pre>"},{"location":"reference.html#lua_rawsetptagged","title":"<code>lua_rawsetptagged</code>","text":"<p><code>void lua_rawsetptagged(lua_State* L, int idx, void* p, int tag)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>p</code>: Arbitrary pointer to be represented as lightuserdata</li> <li><code>tag</code>: Tag</li> </ul> <p>Assuming table <code>t</code> on the stack at <code>idx</code> and <code>v</code> at the top of the stack, this pops <code>v</code> from the stack and adds it to the table: <code>t[p] = v</code>, where <code>p</code> is an arbitrary pointer to some data. Luau will turn this into a lightuserdata value with the given tag.</p> Example<pre><code>struct SomeData {};\nSomeData* data = new SomeData();\n\nlua_newtable(L);\nlua_pushliteral(L, \"hello\");\nlua_rawsetptagged(L, -2, data); // t[data] = \"hello\"\n</code></pre>"},{"location":"reference.html#lua_rawgetptagged","title":"<code>lua_rawgetptagged</code>","text":"<p><code>void lua_rawgetptagged(lua_State* L, int idx, void* p, int tag)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>p</code>: Arbitrary pointer to be represented as lightuserdata</li> <li><code>tag</code>: Tag</li> </ul> <p>Assuming table <code>t</code> on the stack at <code>idx</code>, this pushes to the stack <code>t[p]</code> where <code>t[p]</code> is a lightuserdata with the given tag.</p> Example<pre><code>struct SomeData {};\nSomeData* data = new SomeData();\n\nint tag = 1;\n\nlua_newtable(L);\nlua_pushliteral(L, \"hello\");\nlua_rawsetptagged(L, -2, data, tag); // t[data] = \"hello\"\n\nlua_rawgetptagged(L, -1, data, tag); // v = t[data]\nconst char* s = lua_tostring(L, -1); // \"hello\"\n</code></pre>"},{"location":"reference.html#load-and-call-functions","title":"Load and Call Functions","text":""},{"location":"reference.html#luau_load","title":"<code>luau_load</code>","text":"<p><code>int luau_load(lua_State* L, const char* chunkname, const char* data, size_t size, int env)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>chunkname</code>: Chunk name</li> <li><code>data</code>: Bytecode data</li> <li><code>size</code>: Bytecode data size</li> <li><code>env</code>: Environment</li> </ul> <p>Loads bytecode onto the given thread as a callable function on the top of the stack. If loading fails, the error message is pushed to the stack instead.</p> <p>The <code>chunkname</code> argument helps with debugging.</p> <p>Set <code>env</code> to <code>0</code> to use the default environment. Otherwise, this indicates the stack index for the given environment to use.</p> Example<pre><code>const char* source = \"print('hello')\";\n\nsize_t bytecode_size;\nchar* bytecode = luau_compile(source, strlen(source), nullptr, &amp;bytecode_size);\n\nint res = luau_load(L, \"=test\", bytecode, bytecode_size, 0);\nfree(bytecode);\n\nif (res != 0) {\n    size_t len;\n    const char* msg = lua_tolstring(L, -1, &amp;len);\n    lua_pop(L, 1);\n    printf(\"failed to compile: %s\\n\", msg);\n    return;\n}\n\n// Move loaded chunk to its own thread and run it:\nlua_State* T = lua_newthread(L);\nlua_pushvalue(L, -2);\nlua_remove(L, -3);\nlua_xmove(L, T, 1);\nint status = lua_resume(T, nullptr, 0);\n// ...handle status\n</code></pre>"},{"location":"reference.html#lua_call","title":"<code>lua_call</code>","text":"<p><code>void lua_call(lua_State* L, int nargs, int nresults)</code> <code>[-(nargs + 1), +nresults, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>nargs</code>: Number of arguments</li> <li><code>nresults</code>: Number of returned values</li> </ul> <p>Calls the function at the top of the stack with <code>nargs</code> arguments, and expecting <code>nresults</code> return values. To use <code>lua_call</code>, push the desired function to the stack, and then push the desired arguments to the stack next.</p> <p>If the function errors, the program will need to handle the error. This differs based on how Luau was built. See Error Handling for more information. Also consider using <code>lua_pcall</code> instead.</p> Example<pre><code>int sub(lua_State* L) {\n    double a = luaL_checknumber(L, 1);\n    double b = luaL_checknumber(L, 2);\n    lua_pushnumber(L, a - b);\n    return 1;\n}\n\n// First, push the function:\nlua_pushcfunction(L, sub, \"sub\");\n\n// Next, push function arguments in order:\nlua_pushnumber(L, 15);\nlua_pushnumber(L, 10);\n\n// Finally, call `lua_call`, which will pop the arguments and function from the stack:\nlua_call(L, 2, 1); // 2 args, 1 result\n\ndouble difference = lua_tonumber(L, -1); // result is at the top of the stack\nlua_pop(L, 1); // clean up stack\n\nprintf(\"15 - 10 = %f\\n\", difference);\n</code></pre>"},{"location":"reference.html#lua_pcall","title":"<code>lua_pcall</code>","text":"<p><code>void lua_pcall(lua_State* L, int nargs, int nresults, int errfunc)</code> <code>[-(nargs + 1), +nresults, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>nargs</code>: Number of arguments</li> <li><code>nresults</code>: Number of returned values</li> <li><code>errfunc</code>: Error function index (or 0 for none)</li> </ul> <p>Similar to <code>lua_call</code>, except the function is run in protected mode. The status of the call is returned, which can be checked to see if the call succeeded or not. When successful, results are pushed to the stack in the same way as <code>lua_call</code>.</p> <p>If <code>errfunc</code> is set to <code>0</code>, then the error message will be put onto the stack. Otherwise, <code>errfunc</code> must point to a function on the stack. The function will be called with the given error message. Whatever this error function returns will then be placed onto the stack.</p> Example<pre><code>int sub(lua_State* L) {\n    double a = luaL_checknumber(L, 1);\n    double b = luaL_checknumber(L, 2);\n    lua_pushnumber(L, a - b);\n    return 1;\n}\n\n// First, push the function:\nlua_pushcfunction(L, sub, \"sub\");\n\n// Next, push function arguments in order:\nlua_pushnumber(L, 15);\nlua_pushnumber(L, 10);\n\n// Finally, call `lua_call`, which will pop the arguments and function from the stack:\nint res = lua_pcall(L, 2, 1, 0); // 2 args, 1 result, and no error handler function\n\nif (res == LUA_OK) {\n    double difference = lua_tonumber(L, -1); // result is at the top of the stack\n    lua_pop(L, 1); // clean up stack\n\n    printf(\"15 - 10 = %f\\n\", difference);\n} else {\n    const char* err = lua_tostring(L, -1);\n    lua_pop(L, 1);\n    printf(\"error: %s\\n\", err);\n}\n</code></pre>"},{"location":"reference.html#lua_cpcall","title":"<code>lua_cpcall</code>","text":"<p><code>int lua_cpcall(lua_State* L, lua_CFunction func, void* ud)</code> <code>[-(nargs + 1), +nresults, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>func</code>: C function</li> <li><code>ud</code>: Light userdata</li> </ul> <p>Calls the C function in protected mode, passing <code>ud</code> as the single item on the stack for the function. Returns the status, just like <code>lua_pcall</code>. Functions returned by <code>func</code> are automatically discarded.</p> Example<pre><code>struct Foo {\n    int n;\n};\n\nint fn(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_tolightuserdata(L, 1));\n    foo-&gt;n *= 2;\n    return 0;\n}\n\nFoo foo{};\nfoo.n = 10;\nint status = lua_cpcall(L, fn, &amp;foo);\n\nif (status == LUA_OK) {\n    printf(\"n: %d\\n\", foo.n); // n: 20\n} else {\n    const char* err = lua_tostring(L, -1);\n    lua_pop(L, 1);\n    printf(\"error: %s\\n\", err);\n}\n</code></pre>"},{"location":"reference.html#lual_callyieldable","title":"<code>luaL_callyieldable</code>","text":"<p><code>int luaL_callyieldable(lua_State* L, int nargs, int nresults)</code> <code>[-(nargs + 1), +nresults, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>nargs</code>: Number of arguments</li> <li><code>nresults</code>: Number of returned values</li> </ul> <p>Similar to <code>lua_call</code>, except this function can call yieldable C functions.</p> <p>Returns the status of the call. If the call was a C function and the C function yielded, this will be <code>-1</code>.</p>"},{"location":"reference.html#load-and-call-functions_1","title":"Load and Call Functions","text":""},{"location":"reference.html#lua_yield","title":"<code>lua_yield</code>","text":"<p><code>void lua_yield(lua_State* L, int nresults)</code> <code>[-?, +?, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>nresults</code>: Number of returned values</li> </ul> <p>Yields a coroutine thread. This should only be called as the return value of a C function.</p> <p>The <code>nresults</code> argument indicates how many stack values remain on the thread's stack, allowing the caller of <code>lua_resume</code> to grab those values.</p> Example<pre><code>int do_something(lua_State* L) {\n    // Yield back '15' to the lua_resume call:\n    lua_pushinteger(L, 15);\n    return lua_yield(L, 1);\n}\n\nlua_State* T = lua_newthread(L);\nlua_pushcfunction(T, do_something, \"do_something\");\nint status = lua_resume(L, 0);\nif (status == LUA_YIELD) {\n  int value = lua_tointeger(T, 1); // 15\n  lua_pop(T, 1);\n}\n</code></pre>"},{"location":"reference.html#lua_break","title":"<code>lua_break</code>","text":"<p><code>void lua_break(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Trigger a break (i.e. breakpoint). This is different than <code>lua_breakpoint</code>, which installs a breakpoint.</p>"},{"location":"reference.html#lua_resume","title":"<code>lua_resume</code>","text":"<p><code>int lua_resume(lua_State* L, lua_State* from, int narg)</code> <code>[-?, +?, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>from</code>: From Lua thread</li> <li><code>narg</code>: Number of arguments</li> </ul> <p>Resumes a coroutine. The status of the resumption is returned.</p> <p>To start a new coroutine, do the following: 1. Create a new thread, e.g. <code>lua_newthread</code> 1. Place a function onto the new thread's stack 1. Place arguments in-order onto the new thread's stack (same amount as indicated with <code>narg</code> argument) 1. Call <code>lua_resume</code> 1. Handle the result</p> <p>To resume an existing coroutine: 1. Place arguments onto the thread's stack (These will be the returned result from Luau's <code>coroutine.yield</code> call) 1. Call <code>lua_resume</code> 1. Handle the result</p> Example<pre><code>int add(lua_State* L) {\n    // Get args:\n    int a = luaL_checkinteger(L, 1);\n    int b = luaL_checkinteger(L, 2);\n\n    lua_pushinteger(L, a + b);\n\n    return 1;\n}\n\n// Create thread:\nlua_State* T = lua_newthread(L);\n\n// Push function to thread:\nlua_pushcfunction(add, \"add\");\n\n// Push arguments:\nlua_pushinteger(T, 10);\nlua_pushinteger(T, 20);\n\n// Resume:\nint status = lua_resume(T, L, 2);\n\nif (status == LUA_OK) {\n    // Coroutine is done\n    printf(\"ok\");\n} else if (status == LUA_YIELD) {\n    // Handle yielded thread\n    printf(\"yielded\");\n} else {\n    // Handle error (call lua_getinfo and lua_debugtrace for better debugging and stacktrace information)\n    if (const char* str = lua_tostring(T, -1)) {\n        printf(\"error: %s\\n\", str);\n    } else {\n        printf(\"unknown error: %d\\n\", status);\n    }\n}\n</code></pre>"},{"location":"reference.html#lua_resumeerror","title":"<code>lua_resumeerror</code>","text":"<p><code>int lua_resumeerror(lua_State* L, lua_State* from)</code> <code>[-?, +?, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>from</code>: From Lua thread</li> </ul> <p>Resumes a coroutine, but in an error state. This is useful when reporting an error to a yielded thread.</p> <p>For example, a coroutine might yield to wait for some sort of web request. The yielded thread needs to be resumed, but also needs to report that an error occurred. Thus, <code>lua_resume</code> would not be adequate.</p> <p>The status of the resumption is returned.</p> Example<pre><code>// Some sort of error occurs for our thread, e.g. a web request fails\n// We'll push a string onto the stack to indicate what went wrong\nlua_pushliteral(T, \"oh no, the request failed!\");\n\n// Elsewhere, in some hypothetical task scheduler, we resume the yielded thread:\nint status;\nif (there_was_an_error) {\n    status = lua_resumeerror(T, L);\n} else {\n    // ...normal resumption\n}\n\n// ...handle status\nif (status != LUA_OK &amp;&amp; status != LUA_YIELD) {\n    const char* err = lua_tostring(T, -1); // Might be our \"oh no, the request failed!\" error message\n    // ...other more complete error handling\n}\n</code></pre>"},{"location":"reference.html#lua_status","title":"<code>lua_status</code>","text":"<p><code>int lua_status(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Returns any <code>lua_Status</code> value: lua_Status<pre><code>// Copied from luau/VM/include/lua.h\nenum lua_Status {\n      LUA_OK = 0,\n    LUA_YIELD,\n    LUA_ERRRUN,\n    LUA_ERRSYNTAX, // legacy error code, preserved for compatibility\n    LUA_ERRMEM,\n    LUA_ERRERR,\n    LUA_BREAK, // yielded for a debug breakpoint\n};\n</code></pre></p> Example<pre><code>int all_good(lua_State* L) {\n    return 0;\n}\n\nint oh_no(lua_State* L) {\n    luaL_error(\"oh no!\");\n}\n\nint yield_something(lua_State* L) {\n    return lua_yield(L, 0);\n}\n\nlua_State* T = lua_newthread(L);\nlua_pushcfunction(all_good, \"all_good\");\nint status = lua_resume(T, nullptr, 0); // LUA_OK (0)\n\nlua_State* T = lua_newthread(L);\nlua_pushcfunction(oh_no, \"oh_no\");\nint status = lua_resume(T, nullptr, 0); // LUA_ERRRUN (2)\n\nlua_State* T = lua_newthread(L);\nlua_pushcfunction(yield_something, \"yield_something\");\nint status = lua_resume(T, nullptr, 0); // LUA_YIELD (1)\n</code></pre>"},{"location":"reference.html#lua_isyieldable","title":"<code>lua_isyieldable</code>","text":"<p><code>int lua_isyieldable(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Returns <code>1</code> if the coroutine is yieldable, otherwise <code>0</code>.</p>"},{"location":"reference.html#lua_getthreaddata","title":"<code>lua_getthreaddata</code>","text":"<p><code>void* lua_getthreaddata(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Gets data attached to the given thread. This is arbitrary data that is assigned with <code>lua_setthreaddata</code>.</p>"},{"location":"reference.html#lua_setthreaddata","title":"<code>lua_setthreaddata</code>","text":"<p><code>void lua_setthreaddata(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Sets arbitrary data for a given thread. This is often useful when using lua interrupt or thread callbacks (see <code>lua_callbacks</code>).</p> <p>This value ought not be a Luau-owned object (e.g. data created with <code>lua_newuserdata</code>), since the lifetime of that memory may be shorter than the lifetime of the given thread.</p> Example<pre><code>class Foo {};\n\nlua_setthreaddata(L, new Foo());\n// ...\nFoo* foo = static_cast&lt;Foo*&gt;(lua_getthreaddata(L));\n// ...\nlua_setthreaddata(L, nullptr);\ndelete foo;\n</code></pre>"},{"location":"reference.html#lua_costatus","title":"<code>lua_costatus</code>","text":"<p><code>int lua_costatus(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Gets the coroutine status (<code>lua_CoStatus</code>) of a given thread.</p> lua_CoStatus<pre><code>// Copied from luau/VM/include/lua.h\nenum lua_CoStatus {\n    LUA_CORUN = 0, // running\n    LUA_COSUS,     // suspended\n    LUA_CONOR,     // 'normal' (it resumed another coroutine)\n    LUA_COFIN,     // finished\n    LUA_COERR,     // finished with error\n};\n</code></pre>"},{"location":"reference.html#memory-functions","title":"Memory Functions","text":""},{"location":"reference.html#lua_gc","title":"<code>lua_gc</code>","text":"<p><code>int lua_gc(lua_State* L, int what, int data)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>what</code>: What</li> <li><code>data</code>: Data</li> </ul> <p>Various garbage collection operations, determined by the <code>what</code> argument.</p> <p>Starting and stopping the GC:</p> <ul> <li>To stop the GC: <code>lua_gc(L, LUA_GCSTOP, 0);</code></li> <li>To restart the GC: <code>lua_gc(L, LUA_GCRESTART, 0);</code></li> <li>To run a full GC cycle: <code>lua_gc(L, LUA_GCCOLLECT, 0);</code></li> <li>To run a GC step: <code>lua_gc(L, LUA_GCSTEP, 0);</code></li> </ul> <p>Querying the GC:</p> <ul> <li>To check if the GC is running: <code>if (lua_gc(L, LUA_GCISRUNNING, 0)) {}</code></li> <li>To count GC usage in kilobytes: <code>int kb = lua_gc(L, LUA_GCCOUNT, 0);</code></li> <li>To count the remaining GC in bytes: <code>int b = lua_gc(L, LUA_GCCOUNTB, 0);</code></li> </ul> <p>Tuning the GC:</p> <ul> <li>To set the GC goal (percentage): <code>lua_gc(L, LUA_GCSETGOAL, 200);</code></li> <li>To set the GC step multiplier (percentage): <code>lua_gc(L, LUA_GCSETSTEPMUL, 200);</code></li> <li>To set the GC step size (KB): <code>lua_gc(L, LUA_GCSETSTEPSIZE, 1);</code></li> </ul> Example<pre><code>// Example of querying bytes used:\nint kb = lua_gc(L, LUA_GCCOUNT, 0);\nint bytes_remaining = lua_gc(L, LUA_GCCOUNTB, 0);\nint bytes_total = (kb * 1024) + byte_remaining;\nprintf(\"gc size: %d bytes\", bytes_total);\n</code></pre>"},{"location":"reference.html#lua_setmemcat","title":"<code>lua_setmemcat</code>","text":"<p><code>int lua_setmemcat(lua_State* L, int category)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>category</code>: Memory category</li> </ul> <p>Set the memory category for a given thread (the default is <code>0</code>). There is no associated function to retrieve a thread's current memory category.</p> <p>Call <code>lua_totalbytes</code> to query the amount of memory utilized by a given memory category.</p> <p>Note: While the <code>category</code> parameter is an <code>int</code>, the actual memory category attached to the thread is a <code>uint8_t</code>, and thus the category parameter is cast to <code>uint8_t</code>. Therefore, memory categories are limited to the range <code>[0, 255]</code>.</p> Example<pre><code>// Set the memory category of `L` to 10:\nlua_setmemcat(L, 10);\n</code></pre>"},{"location":"reference.html#lua_totalbytes","title":"<code>lua_totalbytes</code>","text":"<p><code>size_t lua_totalbytes(lua_State* L, int category)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>category</code>: Memory category</li> </ul> <p>Retrieves the total bytes allocated by a given memory category (<code>0</code> is the default memory category). Call <code>lua_setmemcat</code> to assign a memory category for a given thread.</p> Example<pre><code>constexpr uint8_t kExampleMemCat = 10;\n\nlua_State* T = lua_newthread(L);\nlua_setmemcat(T, kExampleMemCat);\nlua_newbuffer(T, 1024 * 10); // 10KB buffer\n\nsize_t total_bytes = lua_totalbytes(T, kExampleMemCat);\nprintf(\"total: %zu bytes\\n\", total_bytes);\n</code></pre>"},{"location":"reference.html#error-functions","title":"Error Functions","text":""},{"location":"reference.html#lua_error","title":"<code>lua_error</code>","text":"<p><code>l_noret lua_error(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Throws a Luau error. Expects the error message to be on the top of the stack. Depending on how Luau is built, this will either perform a <code>longjmp</code> or throw a C++ <code>luau_exception</code>. See Error Handling for more information.</p> <p>Using <code>luaL_error</code> is typically a more ergonomic way to throw errors, since an error message can be provided.</p> Example<pre><code>int multiply_by_two(lua_State* L) {\n    // This is just for example (could use luaL_checknumber instead)\n    if (lua_type(L, 1) != LUA_TNUMBER) {\n        // 1. Push error message to the stack:\n        lua_pushfstring(L, \"expected number; got %s\", luaL_typename(L, 1));\n        // 2. Throw error\n        lua_error(L);\n    }\n\n    double n = lua_tonumber(L, 1);\n    lua_pushnumber(L, n * 2.0);\n    return 1;\n}\n// ...\nlua_pushcfunction(multiply_by_two, \"multiply_by_two\");\nlua_setglobal(L, \"multiply_by_two\");\n</code></pre> Luau Example<pre><code>-- throws error: \"expected number; got string\"\nmultiply_by_two(\"abc\")\n</code></pre>"},{"location":"reference.html#lual_error","title":"<code>luaL_error</code>","text":"<p><code>l_noret luaL_error(lua_State* L, const char* fmt,  ...)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>fmt</code>: Format string</li> <li><code>...</code>: Args</li> </ul> <p>Throws a Luau error with the given error message.</p> Example<pre><code>luaL_error(L, \"something went wrong\");\n\n// Error message can be formatted:\nint some_code = 2;\nconst char* message = \"it zigged but it should have zagged\";\nluaL_error(L, \"%d - %s\", some_code, message);\n</code></pre>"},{"location":"reference.html#lual_typeerror","title":"<code>luaL_typeerror</code>","text":"<p><code>l_noret luaL_typeerror(lua_State* L, int narg, const char* tname)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>narg</code>: Argument number</li> <li><code>tname</code>: Type name</li> </ul> <p>Throws a Luau error with a templated error message for an incorrect type.</p> Example<pre><code>int send_table(lua_State* L) {\n    // expects a table as the first argument\n    if (!lua_istable(L, 1)) {\n        luaL_typeerror(L, 1, \"table\"); // \"invalid argument #1 to 'send_table' (table expected, got &lt;TYPENAME&gt;)\"\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"reference.html#lual_argexpected","title":"<code>luaL_argexpected</code>","text":"<p><code>l_noret luaL_argexpected(lua_State* L, int cond, int narg, const char* tname)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>cond</code>: Condition</li> <li><code>narg</code>: Argument number</li> <li><code>tname</code>: Type name</li> </ul> <p>Throws a Luau error with a templated error message for an incorrect type. This is similar to <code>luaL_typeerror</code>, except it encapsulates a condition, similar to an assertion.</p> Example<pre><code>int send_table(lua_State* L) {\n    // expects a table as the first argument\n    luaL_argexpected(L, lua_istable(L, 1), 1, \"table\");\n\n    // ...\n}\n</code></pre>"},{"location":"reference.html#lual_argerror","title":"<code>luaL_argerror</code>","text":"<p><code>l_noret luaL_argerror(lua_State* L, int narg, const char* extramsg)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>narg</code>: Argument number</li> <li><code>extramsg</code>: Extra message</li> </ul> <p>Throws a Luau error with a templated error message for an incorrect argument.</p> Example<pre><code>int divide(lua_State* L) {\n    double numerator = luaL_checknumber(L, 1);\n    double denominator = luaL_checknumber(L, 2);\n\n    if (denominator == 0) {\n        luaL_argerror(L, 2, \"cannot divide by zero\");\n    }\n\n    lua_pushnumber(L, numerator / denominator);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lual_argcheck","title":"<code>luaL_argcheck</code>","text":"<p><code>l_noret luaL_argcheck(lua_State* L, int cond, int narg, const char* extramsg)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>cond</code>: Condition</li> <li><code>narg</code>: Argument number</li> <li><code>extramsg</code>: Extra message</li> </ul> <p>Throws a Luau error with a templated error message for an incorrect argument. This is similar to <code>luaL_argerror</code>, except it encapsulates a condition, similar to an assertion.</p> Example<pre><code>int divide(lua_State* L) {\n    double numerator = luaL_checknumber(L, 1);\n    double denominator = luaL_checknumber(L, 2);\n\n    luaL_argcheck(L, denominator == 0, 2, \"cannot divide by zero\");\n\n    lua_pushnumber(L, numerator / denominator);\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#miscellaneous-functions","title":"Miscellaneous Functions","text":""},{"location":"reference.html#lua_next","title":"<code>lua_next</code>","text":"<p><code>int lua_next(lua_State* L, int idx)</code> <code>[-1, +(2|0), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>The <code>lua_next</code> function is used to get the next key/pair value in a table, and thus is typically used to iterate a table. Note that <code>lua_rawiter</code> is a faster and preferable way of iterating a table.</p> <p>This function pops a key from the top of the stack and pushes two values: the next key and value in the table. The table is located at the provided <code>idx</code> position on the stack. If there are no more items next within the table, then nothing is pushed to the stack and the function returns <code>0</code>.</p> <p>To get the first key/value pair in a table, use <code>nil</code> as the first key.</p> Example<pre><code>// Assume a table is at the top of the stack\n\nlua_pushnil(L); // First key is nil to indicate we want the first key/value pair from the table\nwhile (lua_next(L, -2) != 0) { // -2 is the stack index for the table\n    // Key is now at index -2\n    // Value is now at index -1\n    printf(\"%s: %s\\n\", luaL_typename(L, -2), luaL_typename(L, -1));\n\n    // Remove 'Value' from the stack, leaving only the Key, which is used\n    // within the next iteration of the loop, and thus is fed back into\n    // the lua_next function.\n    lua_pop(L, 1);\n}\n\n// Nothing to clean up here, as lua_next consumed the keys given. If we happened\n// to break out of the loop early, we would need to pop the key/value items.\n\n// In this example, the table is once again at the top of the stack here.\n</code></pre> <p>The <code>lua_next</code> function can also be used to check if a Luau table is empty. Luau tables can be both arrays and dictionaries, but the <code>lua_objlen</code> function will only count the size of the array portion of the table. Thus, <code>lua_objlen</code> might return <code>0</code> even if the dictionary portion of the array has items. If given a <code>nil</code> key, <code>lua_next</code> will only return <code>0</code> if both the array and dictionary portion of the table are empty.</p> Empty Example<pre><code>bool is_table_empty(lua_State* L, int idx) {\n    // User may provide a negative index to the desired table, but we need\n    // to manipulate the stack, so we can use lua_absindex to get the absolute\n    // index of the table, which will remain stable as we change the stack:\n    int abs_idx = lua_absindex(L, idx);\n\n    lua_pushnil(L);\n    if (lua_next(L, abs_idx)) {\n        lua_pop(L, 2); // Pop the key/value pair produced by lua_next\n        return true;\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"reference.html#lua_rawiter","title":"<code>lua_rawiter</code>","text":"<p><code>int lua_rawiter(lua_State* L, int idx, int iter)</code> <code>[-0, +(0|2), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>iter</code>: Iterator</li> </ul> <p>Allows for iterating over a Luau table. This iterates over both the array and dictionary portions of the table. The <code>idx</code> argument is the stack index of the table. The <code>iter</code> argument is the previous index provided by <code>lua_rawiter</code> (or <code>0</code> for the initial call). See the example below to see how to use this function within a standard for-loop.</p> <p>The current implementation will iterate over the array portion first, followed by the dictionary portion. However, implementation details are not reliable, and any code should not assume this order will always be the same.</p> <p>Note: The returned value of <code>lua_rawiter</code> cannot be used to index directly into the table itself (e.g. <code>lua_rawgeti</code>). Instead, the <code>lua_rawiter</code> function will push the key/value pair onto the stack. These values should both be popped before iterating again.</p> Example<pre><code>// Assume a table is at the top of the stack\n\n// Note the somewhat different for-loop setup, assigning and checking the index\n// within the condition check of the loop, and no update expression is used:\nfor (int index = 0; index = lua_rawiter(L, -1, index), index &gt;= 0;) {\n    // Key is at stack index -2\n    // Value is at stack index -1\n    printf(\"%s:%s\\n\", luaL_typename(L, -2), luaL_typename(L, -1));\n    lua_pop(L, 2); // Pop the key and value\n}\n</code></pre>"},{"location":"reference.html#lua_concat","title":"<code>lua_concat</code>","text":"<p><code>void lua_concat(lua_State* L, int n)</code> <code>[-n, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>n</code>: Number of values</li> </ul> <p>Performs string concatenation on the <code>n</code> values on the top of the stack. All <code>n</code> values are popped, and the resultant string is pushed to the stack. If <code>n</code> is <code>1</code>, this function does nothing. If <code>n</code> is <code>0</code>, an empty string is pushed to the stack. For all other values of <code>n</code> (assuming &gt;= 2), all values are popped and concatenated into a string.</p>"},{"location":"reference.html#lua_encodepointer","title":"<code>lua_encodepointer</code>","text":"<p><code>uintptr_t lua_encodepointer(lua_State* L, uintptr_t p)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>p</code>: Pointer</li> </ul> <p>Encodes a pointer.</p> Example<pre><code>lua_newtable(L);\nconst void* ptr = lua_topointer(L, -1);\nuintptr_t encoded_ptr = lua_encodepointer(L, uintptr_t(ptr));\nprintf(\"Pointer: 0x%016llx\\n\", encoded_ptr);\n</code></pre>"},{"location":"reference.html#lua_clock","title":"<code>lua_clock</code>","text":"<p><code>double lua_clock()</code> <code>[-0, +0, -]</code></p> <p>Returns high-precision timestamp in seconds from the OS. This is exactly what the Luau library function <code>os.clock</code> uses. Here is the OS Clock function implementation:</p> example<pre><code>// Copied from luau/VM/src/loslib.cpp\nstatic int os_clock(lua_State* L) {\n    lua_pushnumber(L, lua_clock());\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#lua_clonefunction","title":"<code>lua_clonefunction</code>","text":"<p><code>void lua_clonefunction(lua_State* L, int idx)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Clones a Luau function at the given index and pushes the cloned function to the top of the stack.</p>"},{"location":"reference.html#lua_cleartable","title":"<code>lua_cleartable</code>","text":"<p><code>void lua_cleartable(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Clears the table at the given index. The internal table capacity does not shrink by default (tables can be configured to shrink by setting <code>__mode = \"s\"</code> on a table's metatable, but only do this if necessary).</p> Example<pre><code>// Create a table with 10 numbers:\nlua_newtable(L);\nfor (int i = 1; i &lt;= 10; i++) {\n    lua_pushinteger(L, i);\n    lua_rawseti(L, -2, i); // t[i] = i\n}\n\nprintf(\"Length: %d\\n\", lua_objlen(L, -1)); // Length: 10\n\nlua_cleartable(L, -1);\n\nprintf(\"Length: %d\\n\", lua_objlen(L, -1)); // Length: 0\n</code></pre>"},{"location":"reference.html#lua_clonetable","title":"<code>lua_clonetable</code>","text":"<p><code>void lua_clonetable(lua_State* L, int idx)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Creates a shallow copy of the table at <code>idx</code> on the stack. The copied table is pushed to the stack.</p> Example<pre><code>// Create a table with 10 numbers:\nlua_newtable(L);\nfor (int i = 1; i &lt;= 10; i++) {\n    lua_pushinteger(L, i);\n    lua_rawseti(L, -2, i); // t[i] = i\n}\n\n// Clone the table:\nlua_clonetable(L, -1);\n\n// Clear the original table:\nlua_cleartable(L, -2);\n\n// Show that they have different lengths:\nprintf(\"Length Original: %d\\n\", lua_objlen(L, -2)); // Length Original: 0\nprintf(\"Length Clone: %d\\n\", lua_objlen(L, -1)); // Length Clone: 10\n</code></pre>"},{"location":"reference.html#lua_getallocf","title":"<code>lua_getallocf</code>","text":"<p><code>lua_Alloc lua_getallocf(lua_State* L, void** ud)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>ud</code>: Userdata</li> </ul> <p>Returns the memory allocator function, and writes the the opaque userdata pointer. These are the values that were originally passed to <code>lua_newstate</code>.</p> <p>Note: <code>ud</code> is only written if the value was provided as non-null to <code>lua_newstate</code>. Beware of garbage values.</p> Example<pre><code>void* ud = nullptr; // Note: explicitly initalized as nullptr\nlua_Alloc alloc_fn = lua_getallocf(L, &amp;ud);\n</code></pre>"},{"location":"reference.html#lua_callbacks","title":"<code>lua_callbacks</code>","text":"<p><code>lua_Callbacks* lua_callbacks(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Allows users to install callback functions for various purposes.</p> Example<pre><code>// Handle Luau panics (only when Luau is built with longjmp, not C++ exceptions)\nstatic void handle_panic(lua_State* L, int errcode) {\n    fprintf(stderr, \"luau panic: %d\\n\", errcode);\n}\n\n// Called when thread 'L' is created or destroyed, denoted if LP (L parent) exists or is null\nstatic void handle_user_thread(lua_State* LP, lua_State* L) {\n    if (LP == nullptr) {\n        // L was destroyed\n    } else {\n        // L was created\n    }\n}\n\nlua_callbacks(L)-&gt;panic = handle_panic;\nlua_callbacks(L)-&gt;userthread = handle_user_thread;\n// ...\n</code></pre>"},{"location":"reference.html#lual_findtable","title":"<code>luaL_findtable</code>","text":"<p><code>const char* luaL_findtable(lua_State* L, int idx, const char* fname, int szhint)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>fname</code>: Name</li> <li><code>szhint</code>: Size hint</li> </ul> <p>Attempts to find or create a table within the table at <code>idx</code>. Using dot-notation within <code>fname</code>, this can be a nested table. The <code>szhint</code> argument indicates how many slots should be allocated in the dictionary portion of the table (if a new table is created).</p> <p>If there is a name conflict (i.e. a value exists with the provided name, but it isn't a table), then said name is returned. Otherwise, <code>NULL</code> is returned.</p> Example<pre><code>// Pushes the table \"my_data\" under the Luau registry to the stack.\n// If the table doesn't exist yet, it is created.\nluaL_findtable(L, LUA_REGISTRYINDEX, \"my_data\", 1);\n\n// Finds table \"another\" within the hierarchy (and creates each parent table as needed)\nluaL_findtable(L, LUA_REGISTRYINDEX, \"mydata.subtable.another\", 1);\n\n// Same as above, except \"my_data\" is sourced from the new table provided.\nlua_newtable(L);\nluaL_findtable(L, -1, \"my_data\", 1);\nlua_pushliteral(L, \"hello\");\nlua_rawsetfield(L, -2, \"message\"); // mydata.message = \"hello\"\n\n// Conflicts are returned (\"hello\" exists within \"my_data\" but isn't a table):\nconst char* conflict = luaL_findtable(L, -1, \"my_data.hello.nested\");\nif (conflict) {\n    printf(\"name conflict: %s\\n\", conflict) // \"name conflict: hello\"\n}\n</code></pre>"},{"location":"reference.html#lual_checktype","title":"<code>luaL_checktype</code>","text":"<p><code>void luaL_checktype(lua_State* L, int narg, int t)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>narg</code>: Argument number</li> <li><code>t</code>: Luau type</li> </ul> <p>Asserts the type at the given index.</p> Example<pre><code>int do_something(lua_State* L) {\n    // Assert that the first argument is a table:\n    luaL_checktype(L, 1, LUA_TTABLE);\n}\n</code></pre>"},{"location":"reference.html#lual_checkoption","title":"<code>luaL_checkoption</code>","text":"<p><code>int luaL_checkoption(lua_State* L, int idx, const char* def, const char* const lst[])</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> <li><code>def</code>: Default option</li> <li><code>lst[]</code>: Options list</li> </ul> <p>Asserts the value at the given index is a string within the given options list <code>lst</code>. If <code>def</code> is provided (non-null), then <code>def</code> will be used as the default option if the value at the given stack index is nil or none. If the assertion passes, the index to the item in the list is returned.</p> Example<pre><code>int set_mode(lua_State* L) {\n    static const char* const options[] = {\"follow\", \"defend\", \"attack\", \"flee\", nullptr};\n\n    int i = luaL_checkoption(L, 1, options[0], options);\n    const char* option = options[i];\n    // ...\n}\n</code></pre>"},{"location":"reference.html#lual_checkany","title":"<code>luaL_checkany</code>","text":"<p><code>void luaL_checkany(lua_State* L, int narg)</code> <code>[-0, +0, m]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>narg</code>: Argument number</li> </ul> <p>Asserts the value at the given index is any value (including <code>nil</code>). In other words, this asserts that the value is not none.</p>"},{"location":"reference.html#lual_register","title":"<code>luaL_register</code>","text":"<p><code>int luaL_register(lua_State* L, const char* libname, const luaL_Reg* l)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>libname</code>: Library name</li> <li><code>l</code>: Functions</li> </ul> <p>Registers a library (i.e. a collection of functions within their own namespace). Internally, this is just a table of functions mapped by their associated key from <code>l</code>.</p> <p>If <code>libname</code> is not null, the library is placed in the Luau registry and the new library table is pushed to the stack. Any Luau code will be able to access the library by name.</p> <p>If <code>libname</code> is null, the function assumes a table is at the top of the stack, and will register all functions into that table.</p> Example<pre><code>// Library functions:\nstatic int do_this(lua_State* L) { /* ... */ }\nstatic int do_that(lua_State* L) { /* ... */ }\n\n// Define library key/pairs:\nstatic const luaL_Reg foo_lib[] = {\n    // {Name, C Function}\n    {\"dothis\", do_this},\n    {\"dothat\", do_that},\n    {nullptr, nullptr}, // End of list is denoted by null pair\n};\n\nvoid open_foo(lua_State* L) {\n    luaL_register(L, \"foo\", foo_lib);\n    lua_pop(L, 1); // luaL_register had left our library on the stack\n}\n</code></pre> Luau Example<pre><code>-- Luau can now access \"foo\":\nfoo.dothis()\nfoo.dothat()\n</code></pre> <p>Alternatively, <code>luaL_register</code> can be used to write the functions to an already-existing table. For instance, a metatable: Example Metatable<pre><code>constexpr int kFooTag = 10;\n\nstruct Foo {};\n\nstatic int Foo_index(lua_State* L) { /* ... */ }\nstatic int Foo_newindex(lua_State* L) { /* ... */ }\nstatic int Foo_tostring(lua_State* L) { /* ... */ }\n\nstatic const luaL_Reg foo_mt[] = {\n    {\"__index\", Foo_index},\n    {\"__newindex\", Foo_newindex},\n    {\"__tostring\", Foo_tostring},\n    {nullptr, nullptr},\n};\n\nvoid Foo_setup_metatable(lua_State* L) {\n    luaL_newmetatable(L, \"Foo\");\n    luaL_register(L, nullptr, foo_mt);\n    lua_setuserdatametatable(L, kFooTag);\n}\n</code></pre></p>"},{"location":"reference.html#ref-functions","title":"Ref Functions","text":""},{"location":"reference.html#lua_ref","title":"<code>lua_ref</code>","text":"<p><code>int lua_ref(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Creates a reference to the given Luau value at <code>idx</code> on the stack. The returned integer can be seen as an opaque handle to the value. Creating a reference is also an easy way to pin a Luau value, preventing it from being GC'd. A reference can be created for any value on the stack. Attempting to create a reference to a nil value will return <code>LUA_REFNIL</code>.</p> <p>Be sure to call <code>lua_unref</code> when done with the reference. Call <code>lua_getref</code> to retrieve the referenced value.</p> <p>Note: Unlike in Lua, Luau does not modify the stack when creating a reference. The stack remains the same.</p> Example<pre><code>lua_newtable(L);\nint table_ref = lua_ref(L, -1);\nlua_pop(L, 1);\n// GC won't clean up the table, even though it was popped, becase a reference\n// has been created for the table.\n</code></pre>"},{"location":"reference.html#lua_unref","title":"<code>lua_unref</code>","text":"<p><code>void lua_unref(lua_State* L, int ref)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>ref</code>: Reference</li> </ul> <p>Removes a reference that was originally created with <code>lua_ref</code>. Passing in <code>LUA_REFNIL</code> or <code>LUA_NOREF</code> is allowed (in those cases, the function does nothing). However, passing in an already-removed reference is not allowed and may throw an error, or silently remove another reference. If idempotence is required, ensure your reference variable is set to <code>LUA_REFNIL</code> or <code>LUA_NOREF</code> after calling <code>lua_unref</code>.</p> Example<pre><code>lua_newtable(L);\nint table_ref = lua_ref(L, -1);\n\n// Sometime later:\nlua_unref(L, table_ref);\n</code></pre>"},{"location":"reference.html#lua_getref","title":"<code>lua_getref</code>","text":"<p><code>int lua_getref(lua_State* L, int ref)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>ref</code>: Reference</li> </ul> <p>Retrieves the value from a given reference handle. The value is pushed to the top of the stack.</p> Example<pre><code>lua_newtable(L);\nint table_ref = lua_ref(L, -1);\n\n// Sometime later:\nlua_getref(L, table_ref);\n// Top of stack is now the table from the reference\n</code></pre>"},{"location":"reference.html#type-functions","title":"Type Functions","text":""},{"location":"reference.html#lua_isfunction","title":"<code>lua_isfunction</code>","text":"<p><code>int lua_isfunction(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a function.</p> Example<pre><code>if (lua_isfunction(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_istable","title":"<code>lua_istable</code>","text":"<p><code>int lua_istable(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a table.</p> Example<pre><code>if (lua_istable(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_isnil","title":"<code>lua_isnil</code>","text":"<p><code>int lua_isnil(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is nil.</p> Example<pre><code>if (lua_isnil(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_isthread","title":"<code>lua_isthread</code>","text":"<p><code>int lua_isthread(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is a thread.</p> Example<pre><code>if (lua_isthread(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_isnone","title":"<code>lua_isnone</code>","text":"<p><code>int lua_isnone(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is none.</p> Example<pre><code>if (lua_isnone(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lua_isnoneornil","title":"<code>lua_isnoneornil</code>","text":"<p><code>int lua_isnoneornil(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Checks if the value at the given stack index is none or nil.</p> Example<pre><code>if (lua_isnoneornil(L, -1)) { /* ... */ }\n</code></pre>"},{"location":"reference.html#lual_typename","title":"<code>luaL_typename</code>","text":"<p><code>const char* luaL_typename(lua_State* L, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>idx</code>: Stack index</li> </ul> <p>Returns the name of the type at the given index.</p> Example<pre><code>lua_pushvector(L, 10, 20, 30);\nconst char* t_name = luaL_typename(L, -1);\nprintf(\"Type: %s\\n\", t_name); // \"Type: vector\"\n</code></pre>"},{"location":"reference.html#string-buffer-functions","title":"String Buffer Functions","text":""},{"location":"reference.html#lual_buffinit","title":"<code>luaL_buffinit</code>","text":"<p><code>void luaL_buffinit(lua_State* L, luaL_Buffer* B)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>B</code>: Lua string buffer</li> </ul> <p>Initializes a string buffer.</p> Example<pre><code>luaL_Strbuf b;\nluaL_buffinit(L, &amp;b);\n</code></pre>"},{"location":"reference.html#lual_buffinitsize","title":"<code>luaL_buffinitsize</code>","text":"<p><code>char* luaL_buffinitsize(lua_State* L, luaL_Buffer* B, size_t size)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>B</code>: Lua string buffer</li> <li><code>size</code>: Preallocated size</li> </ul> <p>Initializes a string buffer with an initial allocated size. A pointer to the start of the buffer is returned.</p> Example<pre><code>luaL_Strbuf b;\nchar* buf = luaL_buffinitsize(L, &amp;b, 512);\n</code></pre>"},{"location":"reference.html#lual_prepbuffsize","title":"<code>luaL_prepbuffsize</code>","text":"<p><code>char* luaL_prepbuffsize(luaL_Buffer* B, size_t size)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>size</code>: Size extension</li> </ul> <p>Ensure the string buffer has at least <code>size</code> capacity available. For instance, if 10 characters need to be added to an existing string buffer, it may be more optimal to call <code>luaL_prepbuffsize(&amp;b, 10)</code> before adding each character.</p>"},{"location":"reference.html#lual_addchar","title":"<code>luaL_addchar</code>","text":"<p><code>void luaL_addchar(luaL_Buffer* B, char c)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>c</code>: Character</li> </ul> <p>Adds a character to a string buffer.</p>"},{"location":"reference.html#lual_addlstring","title":"<code>luaL_addlstring</code>","text":"<p><code>void luaL_addlstring(luaL_Buffer* B, const char* s, size_t l)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>s</code>: String</li> <li><code>l</code>: String length</li> </ul> <p>Adds a string to a string buffer.</p>"},{"location":"reference.html#lual_addstring","title":"<code>luaL_addstring</code>","text":"<p><code>void luaL_addstring(luaL_Buffer* B, const char* s)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>s</code>: String</li> </ul> <p>Adds a string to a string buffer. If the length of the string is known, use <code>luaL_addlstring</code> instead.</p>"},{"location":"reference.html#lual_addvalue","title":"<code>luaL_addvalue</code>","text":"<p><code>void luaL_addvalue(luaL_Buffer* B)</code> <code>[-1, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> </ul> <p>Pops a value from the top of the stack and adds it to the buffer.</p>"},{"location":"reference.html#lual_addvalueany","title":"<code>luaL_addvalueany</code>","text":"<p><code>void luaL_addvalueany(luaL_Buffer* B, int idx)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>idx</code>: Stack index</li> </ul> <p>Adds the value at the given stack index into the buffer. Unlike <code>luaL_addvalue</code>, this does not pop the item from the stack.</p>"},{"location":"reference.html#lual_pushresult","title":"<code>luaL_pushresult</code>","text":"<p><code>void luaL_pushresult(luaL_Buffer* B)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> </ul> <p>Pushes the result of the string buffer onto the stack.</p>"},{"location":"reference.html#lual_pushresultsize","title":"<code>luaL_pushresultsize</code>","text":"<p><code>void luaL_pushresultsize(luaL_Buffer* B, size_t size)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>B</code>: Lua string buffer</li> <li><code>size</code>: Size</li> </ul> <p>Pushes the result of the string buffer onto the stack, assuming <code>size</code> extra length on the buffer. This is only used if the buffer is being directly written rather than going through other string buffer functions that track the size.</p> Example<pre><code>// Copied from luau/VM/src/lstrlib.cpp\n\n// Note how the buffer is initialized to the correct size, but\n// the buffer is being written to directly, rather than going\n// through the `luaL_addchar` function.\nstatic int str_lower(lua_State* L) {\n    size_t l;\n    const char* s = luaL_checklstring(L, 1, &amp;l);\n    luaL_Strbuf b;\n    char* ptr = luaL_buffinitsize(L, &amp;b, l); // buffer initialized\n    for (size_t i = 0; i &lt; l; i++) {\n        *ptr++ = tolower(uchar(s[i])); // direct write\n    }\n    luaL_pushresultsize(&amp;b, l); // push result\n    return 1;\n}\n</code></pre>"},{"location":"reference.html#debug-functions","title":"Debug Functions","text":""},{"location":"reference.html#lua_stackdepth","title":"<code>lua_stackdepth</code>","text":"<p><code>int lua_stackdepth(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Returns the current stack depth.</p>"},{"location":"reference.html#lua_getinfo","title":"<code>lua_getinfo</code>","text":"<p><code>int lua_getinfo(lua_State* L, int level, const char* what, lua_Debug* ar)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>what</code>: Desired information</li> <li><code>ar</code>: Debug info (activation record)</li> </ul> <p>Gets debug information for the given stack level. The characters in the <code>what</code> string indicate what information is desired.</p> <p>The <code>what</code> string may contain:</p> <ul> <li><code>n</code>: Fills the <code>name</code> field</li> <li><code>s</code>: Fills the <code>what</code>, <code>source</code>, <code>short_src</code>, and <code>linedefined</code> fields</li> <li><code>l</code>: Fills the <code>currentline</code> field</li> <li><code>u</code>: Fills the <code>nupvals</code> field</li> <li><code>a</code>: Fills the <code>nparams</code> and <code>isvararg</code> fields</li> <li><code>f</code>: Pushes closure to the stack</li> </ul> <p>For example, if <code>name</code>, <code>currentline</code>, and <code>short_src</code> is desired, the <code>what</code> string could be set to <code>\"nsl\"</code>.</p> <p>Returns <code>0</code> on failure, otherwise <code>1</code>.</p> Example<pre><code>lua_State* T = lua_newthread(L);\n// ... setup T to have a function to resume\n\nint status = lua_resume(T, nullptr, 0);\n\n// Use lua_getinfo to create a clearer error message:\nif (status != LUA_OK &amp;&amp; status != LUA_YIELD) {\n    std::string error;\n\n    lua_Debug ar;\n    if (lua_getinfo(L, 0, \"nsl\")) {\n        error += ar.short_src;\n        error += ':';\n        error += std::to_string(ar.currentline);\n        error += \": \";\n    }\n\n    if (const char* str = lua_tostring(T, -1)) {\n        error += str;\n    }\n\n    error += \"\\nstacktrace:\\n\";\n    error += lua_debugtrace(T);\n\n    fprintf(stderr, \"%s\\n\", error.c_str());\n}\n</code></pre>"},{"location":"reference.html#lua_getargument","title":"<code>lua_getargument</code>","text":"<p><code>int lua_getargument(lua_State* L, int level, int n)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>n</code>: Argument number</li> </ul> <p>Gets argument <code>n</code> at the given stack level. If found, the value is pushed to the top of the stack and the function returns <code>1</code>. Otherwise, the function returns <code>0</code> and nothing is pushed to the stack.</p>"},{"location":"reference.html#lua_getlocal","title":"<code>lua_getlocal</code>","text":"<p><code>int lua_getlocal(lua_State* L, int level, int n)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>n</code>: Argument number</li> </ul> <p>Gets a local variable at the given stack level and pushes the value onto the stack. The name of the local variable is returned, and the value on the stack is popped. If no local is found, <code>NULL</code> is returned and nothing is pushed to the stack.</p>"},{"location":"reference.html#lua_setlocal","title":"<code>lua_setlocal</code>","text":"<p><code>int lua_setlocal(lua_State* L, int level, int n)</code> <code>[-(0|1), +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>n</code>: Argument number</li> </ul> <p>Sets a local variable at the given stack level to the value at the top of the stack. The name of the local variable is returned, and the value on the stack is popped. If no local is found, <code>NULL</code> is returned and nothing is popped from the stack.</p>"},{"location":"reference.html#lua_getupvalue","title":"<code>lua_getupvalue</code>","text":"<p><code>int lua_getupvalue(lua_State* L, int level, int n)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>n</code>: Argument number</li> </ul> <p>Pushes an upvalue to the stack, and returns its name. If not found, returns <code>NULL</code> and nothing is pushed to the stack.</p>"},{"location":"reference.html#lua_setupvalue","title":"<code>lua_setupvalue</code>","text":"<p><code>int lua_setupvalue(lua_State* L, int level, int n)</code> <code>[-0, +(0|1), -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> <li><code>n</code>: Argument number</li> </ul> <p>Pops a value off the stack and sets the given upvalue with the popped value, and returns its name. If not found, returns <code>NULL</code> and nothing is popped from the stack.</p>"},{"location":"reference.html#lua_singlestep","title":"<code>lua_singlestep</code>","text":"<p><code>int lua_singlestep(lua_State* L, int enabled)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>enabled</code>: Enabled</li> </ul> <p>Enables or disables single-step mode.</p>"},{"location":"reference.html#lua_breakpoint","title":"<code>lua_breakpoint</code>","text":"<p><code>int lua_breakpoint(lua_State* L, int funcindex, int line, int enabled)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>funcindex</code>: Function index</li> <li><code>line</code>: Line</li> <li><code>enabled</code>: Enabled</li> </ul> <p>Enables or disables a breakpoint at the given line within the given function at <code>funcindex</code> on the stack.</p>"},{"location":"reference.html#lua_getcoverage","title":"<code>lua_getcoverage</code>","text":"<p><code>void lua_getcoverage(lua_State* L, int funcindex, void* context, lua_Coverage callback)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>funcindex</code>: Function index</li> <li><code>context</code>: Context</li> <li><code>callback</code>: Coverage callback function</li> </ul> <p>Get coverage.</p>"},{"location":"reference.html#lua_debugtrace","title":"<code>lua_debugtrace</code>","text":"<p><code>const char* lua_debugtrace(lua_State* L)</code> <code>[-0, +0, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> </ul> <p>Gets a traceback string.</p> <p>Note: Internally, this uses a static string buffer. Thus, this function is not thread-safe, nor is it safe to hold onto the returned value. Create a copy of the returned string if needed.</p>"},{"location":"reference.html#lual_where","title":"<code>luaL_where</code>","text":"<p><code>void luaL_where(lua_State* L, int level)</code> <code>[-0, +1, -]</code></p> <ul> <li><code>L</code>: Lua thread</li> <li><code>level</code>: Stack level</li> </ul> <p>Pushes a string onto the stack containing the short source and current line, e.g. <code>\"some/script.luau:10: \"</code>. This is often used as a prefix for other debug logging information.</p>"},{"location":"guides/atoms.html","title":"Atoms","text":""},{"location":"guides/atoms.html#the-problem","title":"The Problem","text":"<p>Consider a method handler that has to deal with multiple different methods. Luau gives us the string of the method, and then we compare the string against all the possible methods. The same scenario can be played out for handling read/write indexing.</p> <pre><code>struct Foo {};\n\nstatic int Foo_namecall(lua_State* L) {\n    const char* method = lua_namecallatom(L, nullptr);\n\n    if (strcmp(method, \"DoThis\") == 0) {\n        // ...\n        return 0;\n    }\n    if (strcmp(method, \"DoThat\") == 0) {\n        // ...\n        return 0;\n    }\n    if (strcmp(method, \"RemoveThis\") == 0) {\n        // ...\n        return 0;\n    }\n    if (strcmp(method, \"RemoveThat\") == 0) {\n        // ...\n        return 0;\n    }\n    // ...\n}\n</code></pre> <p>Our <code>strcmp</code> chain is not very efficient. A better way would be something similar to our Tags solution. Atoms are similar to tags, as they allow us to assign a number per unique string. Luau already interns strings, so Luau is capable of attaching other metadata to those strings, e.g. atoms.</p>"},{"location":"guides/atoms.html#what-is-an-atom","title":"What is an Atom?","text":"<p>An atom is an integer (<code>int16_t</code>). That's it! We can assign this integer to strings via a callback, and then we can inspect this integer with special string functions which include the atom.</p>"},{"location":"guides/atoms.html#how-to-use-atoms","title":"How to Use Atoms","text":"<p>The <code>lua_callbacks</code> function allows us to install a <code>useratom</code> callback. This callback gets called for any string without an assigned atom that is fetched through a function that also returns an atom, e.g. <code>lua_namecallatom</code> and <code>lua_tostringatom</code>. In other words, if you call <code>lua_namecallatom</code> and provide the <code>atom</code> argument, Luau will first call the <code>useratom</code> callback if there is no atom assigned, and then will write the atom to your <code>atom</code> argument.</p> Fetching Atom<pre><code>static int Foo_namecall(lua_State* L) {\n    int atom;\n    const char* method = lua_namecallatom(L, &amp;atom);\n    // ...\n}\n</code></pre> <p>If no <code>useratom</code> callback is installed, then the atom will always be <code>-1</code>. Although atoms are written back as <code>int</code> types, atoms are internally stored as <code>int16_t</code>, so we can assign any value in the range of <code>[-32768, 32767]</code>. However, do not use the value of <code>ATOM_UNDEF</code> (which currently is set to the minimum value, <code>-32768</code>), as Luau will treat that as an unset atom and call the <code>useratom</code> callback again for the string.</p> <p>Let's install a simple <code>useratom</code> callback for demonstration purposes. In a real-life scenario, it is probably better to compile some sort of lookup list ahead of time.</p> Atoms<pre><code>// my_atoms.h\nconstexpr int16_t kAtomDoThis = 1;\nconstexpr int16_t kAtomDoThat = 2;\nconstexpr int16_t kAtomRemoveThis = 3;\nconstexpr int16_t kAtomRemoveThat = 4;\n</code></pre> Useratom Callback<pre><code>#include \"my_atoms.h\"\n\nstatic int16_t handle_useratom(const char* s, size_t l) {\n    // Match the string to the desired atom value:\n    if (strcmp(s, \"DoThis\") == 0) {\n        return kAtomDoThis;\n    }\n    if (strcmp(s, \"DoThat\") == 0) {\n        return kAtomDoThat;\n    }\n    if (strcmp(s, \"RemoveThis\") == 0) {\n        return kAtomRemoveThis;\n    }\n    if (strcmp(s, \"RemoveThat\") == 0) {\n        return kAtomRemoveThat;\n    }\n\n    // If our list is dynamically changing, and we want Luau to\n    // call this atom handler again for the same string, then we\n    // should return `ATOM_UNDEF`. Otherwise, for static lists,\n    // just return whatever value you want to use to indicate\n    // that no atom was found, but DON'T return `ATOM_UNDEF`:\n    return -1;\n}\n\n// Call this during our initial state setup\nvoid install_atom_callback(lua_State* L) {\n    lua_callbacks(L)-&gt;useratom = handle_useratom;\n}\n</code></pre> <p>Now we can modify our <code>Foo_namecall</code> function to utilize the atoms instead of a bunch of <code>strcmp</code> calls. Simple integer comparisons will perform much better.</p> <pre><code>#include \"my_atoms.h\"\n\nstatic int Foo_namecall(lua_State* L) {\n    int atom;\n    const char* method = lua_namecallatom(L, &amp;atom);\n\n    if (atom == kAtomDoThis) {\n        // ...\n        return 0;\n    }\n    if (atom == kAtomDoThat) {\n        // ...\n        return 0;\n    }\n    if (atom == kAtomRemoveThis) {\n        // ...\n        return 0;\n    }\n    if (atom == kAtomRemoveThat) {\n        // ...\n        return 0;\n    }\n    // ...\n}\n</code></pre> <p>To reiterate, the <code>useratom</code> callback is only invoked when both of these conditions are met:</p> <ol> <li>An atom-fetching function is called with the provided atom callback, e.g. <code>lua_namecallatom(L, &amp;atom)</code></li> <li>The string has yet to have the <code>useratom</code> function called on it (i.e. its atom is currently <code>ATOM_UNDEF</code>)</li> </ol> <p>If Luau attempts to fetch a string atom before the <code>useratom</code> callback is installed, then the atom will be set to <code>-1</code>. Thus, ensure that you are installing the callback during your initial setup, before any Luau code is run.</p> <p>As of writing this, the Luau <code>lua.h</code> header file incorrectly states that the <code>useratom</code> function gets called when a string is created. This is not true. This was the old behavior, but was later changed in release 0.536.</p>"},{"location":"guides/buffers.html","title":"Buffers","text":"<p>In Luau, buffers are arbitrary chunks of memory. Luau can interact with these values through the <code>buffer</code> library.</p> <p>Buffers are useful when Luau needs to interact with raw data. Buffers cannot be resized, but they can be modified.</p> <pre><code>// Allow Luau to fetch the binary contents of a file:\nint read_file(lua_State* L) {\n    const char* filepath = luaL_checkstring(L, 1);\n    std::ifstream file(filepath, std::ios::binary);\n    if (!file.is_open()) {\n        luaL_error(\"failed to open file: %s\", filepath);\n    }\n\n    std::string data;\n    std::string line;\n    while (std::getline(file, line)) {\n        data += line;\n    }\n\n    // Create Luau buffer:\n    void* buf = lua_newbuffer(L, data.size());\n\n    // Write to buffer:\n    memcpy(buf, data.data(), data.size());\n\n    return 1;\n}\n\n// Expose to Luau:\nlua_pushcfunction(L, read_file, \"read_file\");\nlua_setglobal(L, \"read_file\");\n</code></pre> <p>Now we can read a file from Luau: <pre><code>local filepath = \"some/path/whatever.jpg\"\nlocal buf = read_file(filepath)\nprint(`size of {filepath}: {buffer.len(buf)}`)\n</code></pre></p>"},{"location":"guides/error-handling.html","title":"Error Handling","text":"<p>Coming soon. Assertion callback, longjmp vs. exceptions, etc.</p>"},{"location":"guides/light-userdata.html","title":"Light Userdata","text":"<p>A light userdata value simply wraps a pointer to data that you manage. This is useful when you want to share a non-Luau-managed value somewhere within Luau, e.g. the Luau registry.</p> <p>Luau does not assume ownership of the memory pointed to by the light userdata. You are responsible for the memory.</p>"},{"location":"guides/light-userdata.html#example","title":"Example","text":"<pre><code>struct Foo {};\n\n// Memory of foo owned by our program; not owned by Luau\nFoo* foo = new Foo();\n\n// Store a pointer to foo within the registry:\nlua_pushlightuserdata(L, foo);\nlua_rawsetfield(L, LUA_REGISTRYINDEX, \"Foo\");\n\n// Retrieve foo:\nlua_rawgetfield(L, LUA_REGISTRYINDEX, \"Foo\");\nFoo* foo = static_cast&lt;Foo*&gt;(lua_tolightuserdata(L, -1));\nlua_pop(L, 1); // pop the lightuserdata value\n\n// We are responsible for freeing foo:\ndelete foo;\n</code></pre>"},{"location":"guides/light-userdata.html#tags","title":"Tags","text":"<p>Similar to userdata types, light userdata can also be assigned a tag. This can help ensure we don't type-cast to the wrong type. If we call <code>lua_tolightuserdatatagged</code> on a light userdata with the incorrect tag, it will simply return <code>NULL</code>.</p> <pre><code>constexpr int kFooTag = 10;\n\nFoo* foo = new Foo();\n\n// Push with tag:\nlua_pushlightuserdatatagged(L, foo, kFooTag);\n\n// Retrieve with tag:\nFoo* f = static_cast&lt;Foo*&gt;(lua_tolightuserdatatagged(L, -1, kFooTag));\n</code></pre>"},{"location":"guides/native-userdata.html","title":"Native Userdata","text":"<p>While Native Code Generation (NCG) might give a boost for built-in Luau libraries and functions, there is no real gain for custom userdata types out of the box.</p> <p>Luau includes APIs to generate IR (intermediate representation) code for userdata accesses, method calls, and some other metamethod calls. This may result in significant performance benefits. The process of generating IR is often referred to as \"IR Lowering.\" To generalize, you can think of IR code as the middleman between actual source code and native code. The IR code is then processed into native code. Thus, only one version of IR code must be generated, which then allows multiple native targets. In other words, you only need to write one IR generation for your userdata, rather than multiple native ones.</p> <p>Note: Some of the code and examples are taken from the <code>IrLowering</code> conformance test.</p>"},{"location":"guides/native-userdata.html#setup","title":"Setup","text":"<p>Using tagged userdata types is the first step in this whole process. Follow the Userdata Tags guide for more info.</p>"},{"location":"guides/native-userdata.html#define-types","title":"Define Types","text":"<p>Next, we need to tell Luau the name of our userdata types. In this example, we'll build out a simple Vector2 userdata type. Thus, we'll define our null-terminated type array as such:</p> <pre><code>static const char* kUserdataTypes[] = {\n    \"Vector2\",\n    nullptr,\n};\n</code></pre> <p>We will also benefit from hard-coding the index for each value in our array. These do not need to be the same value as the tag itself.</p> <pre><code>constexpr uint8_t kVector2Type = 0;\n</code></pre>"},{"location":"guides/native-userdata.html#remap","title":"Remap","text":"<p>When we initially open up the Luau state and enable native codegen, we need to also assign a runtime userdata type remapper callback. This will essentially do the same thing as we hard-coded: get the index of a type within the <code>kUserdataTypes</code> array. See this discussion for more info.</p> <p>The code can look something like this:</p> <pre><code>#include &lt;Luau/CodeGen.h&gt;\n#include &lt;string_view&gt;\n\nLuau::CodeGen::create(L); // instead of luau_codegen_create(L)\n\n// Map a type (str) to the expected index\nLuau::CodeGen::setUserdataRemapper(\n    L,\n    kUserdataTypes,\n    [](void* ctx, const char* str size_t len) -&gt; uint8_t {\n        const char** types = (const char**)ctx;\n        uint8_t idx = 0;\n        std::string_view sv{str, len};\n\n        for (; *types; ++types) {\n            if (sv == *types) {\n                return idx;\n            }\n            idx++;\n        }\n\n        // For failed matches, we must return 0xff:\n        return 0xff;\n    }\n)\n</code></pre>"},{"location":"guides/native-userdata.html#normal-compilation","title":"Normal Compilation","text":"<p>We first need to add the <code>kUserdataTypes</code> array to our Luau compilation options struct.</p> <pre><code>lua_CompileOptions options{};\n// ... other options\n\noptions.userdataTypes = kUserdataTypes;\n\n// ...\nchar data = luau_compile(source, source_len, &amp;options, &amp;data_len);\n</code></pre>"},{"location":"guides/native-userdata.html#native-compilation","title":"Native Compilation","text":"<p>In the Native guide, we used the Luau API <code>luau_codegen_compile</code> function. Unfortunately, that function does not allow us to pass NCG options. Thus, we will need to use the Luau namespace within the Luau CodeGen library instead: <code>Luau::CodeGen::compile(...)</code>.</p> <p>Just like before, we call this after our code has been loaded with <code>luau_load</code>.</p> <pre><code>int res = luau_load(L, ...);\n// ...handle res\n\nif (Luau::CodeGen::isSupported()) {\n    Luau::CodeGen::CompilationOptions native_opts{};\n\n    // Assign our userdata types here too, which helps in better codegen:\n    native_opts.userdataTypes = kUserdataTypes;\n\n    // ...other options (we'll cover them next)\n\n    Luau::CodeGen::compile(L, -1, native_opts);\n}\n</code></pre> <p>Note that we assign our same <code>kUserdataTypes</code> array to the native compilation options too. Optionally, the return type of <code>compile</code> (<code>Luau::CodeGen::CompilationResult</code>) can also be captured to inspect the result of the compilation.</p>"},{"location":"guides/native-userdata.html#ir-generation","title":"IR Generation","text":"<p>Now comes the fun part. We need to instruct Luau on two fronts: (1) what Luau type is expected for a given field, and (2) what IR code should be generated.</p> <p>For the sake of simplicity, we will only focus on accessing the \"x\" and \"y\" properties of a custom Vector2 userdata. Let's assume the backing struct for this userdata looks like this:</p> <pre><code>struct Vector2 {\n    float x;\n    float y;\n}\n</code></pre> <p>Also note that this does not replace your standard code for interfacing with userdata, such as creating a metatable and assigning metamethods.</p>"},{"location":"guides/native-userdata.html#access-type","title":"Access Type","text":"<p>The first step is to tell Luau what bytecode type to expect when accessing our Vector2. This is done through the <code>userdataAccessBytecodeType</code> callback on the native compilation options struct.</p> <p>Here's a stub for our first callback:</p> <pre><code>#include &lt;Luau/Bytecode.h&gt;\n\nuint8_t ud_access_bytecode_type(uint8_t type, const char* member, size_t member_len) {\n    // Fallback to \"any\" type:\n    return LBC_TYPE_ANY;\n}\n</code></pre> <p>We need to assign this callback to our native code generation options:</p> <pre><code>native_opts.userdataAccessBytecodeType = ud_access_bytecode_type;\n</code></pre> <p>Before we start filling out our callback, we first need to write a couple of functions to map between our userdata index (e.g. <code>kIrVector2</code>) and the type index Luau uses (which is just an offset from <code>LBC_TYPE_TAGGED_USERDATA_BASE</code>). These two helper functions will look like this:</p> <pre><code>static inline uint8_t type_to_ud_idx(uint8_t type) {\n    return type - LBC_TYPE_TAGGED_USERDATA_BASE;\n}\n\nstatic inline uint8_t ud_idx_to_type(uint8_t ud_idx) {\n    return LBC_TYPE_TAGGED_USERDATA_BASE + ud_idx;\n}\n</code></pre> <p>Within our callback, we need to tell Luau that our \"x\" and \"y\" properties should be typed as numbers (<code>LBC_TYPE_NUMBER</code>).</p> <pre><code>uint8_t ud_access_bytecode_type(uint8_t type, const char* member, size_t member_len) {\n    switch (type_to_ud_idx(type)) {\n    case kIrVector2:\n        if (strcmp(member, \"x\") == 0 || strcmp(member, \"y\") == 0) {\n            return LBC_TYPE_NUMBER;\n        }\n        break;\n\n    default:\n        break;\n    }\n\n    return LBC_TYPE_ANY;\n}\n</code></pre> <p>When Luau sees \"vec2.x\" (and when it knows vec2 is a Vector2 from the given type), then our callback will inform Luau that the expected access type is a number.</p>"},{"location":"guides/native-userdata.html#ir-builder","title":"IR Builder","text":"<p>Our final step is to generate the necessary intermediate code for our \"x\" and \"y\" properties.</p> <p>Let's write our stub first:</p> <pre><code>bool ud_access(\n    IrBuilder&amp; build,\n    uint8_t type,\n    const char* member,\n    size_t member_len,\n    int result_reg,\n    int source_reg,\n    int pcpos\n) {\n    // We return 'false' if no IR code is generated:\n    return false;\n}\n</code></pre> <p>Assign the callback to the native options, just like our previous callback:</p> <pre><code>native_opts.userdataAccess = ud_access;\n</code></pre> <p>Our next chunk of code will be the most complicated, as we're interfacing with Luau's <code>IrBuilder</code>. The various commands are documented in Luau's CodeGen <code>IrData.h</code> header. Other than that, there is not much documentation outside of just reading the source code.</p> <p>The gist of what we want to do is:</p> <ol> <li>Load our userdata value from the <code>source_reg</code> VM register.</li> <li>Run a check to ensure the value is indeed our Vector2-tagged userdata.</li> <li>Read the \"x\" or \"y\" float property.</li> <li>Store the result and type into the <code>result_reg</code> VM registry.</li> </ol> <p>Let's write the code for reading \"x\" first. The code for \"y\" will be almost identical, other than the offset into our data struct.</p> <pre><code>void gen_ir_vector2_x(IrBuilder&amp; build, int result_reg, source_reg, int pcpos) {\n    // Load the userdata\n    IrOp udata = build.inst(IrCmd::LOAD_POINTER, build.vmReg(source_reg));\n\n    // Check that our userdata is a Vector2 using our tag\n    // (This assumes `kVector2Tag` is the tag value)\n    build.inst(IrCmd::CHECK_USERDATA_TAG, udata, build.constInt(kVector2Tag), build.vmExit(pcpos));\n\n    // Load the value (note the 'offsetof' macro, grabbing the proper offset to 'x' in 'Vector2')\n    IrOp value = build.inst(IrCmd::BUFFER_READF32, udata, build.constInt(offsetof(Vector2, x)), build.constTag(LUA_TUSERDATA));\n\n    // Store the value of 'x' into the result register:\n    build.inst(IrCmd::STORE_DOUBLE, build.vmReg(result_reg), value);\n\n    // Store the type of 'x' into the result register:\n    build.inst(IrCmd::STORE_TAG, build.vmReg(result_reg), build.constTag(LUA_TNUMBER));\n}\n\nbool ud_access(\n    IrBuilder&amp; build,\n    uint8_t type,\n    const char* member,\n    size_t member_len,\n    int result_reg,\n    int source_reg,\n    int pcpos\n) {\n    switch (type_to_ud_idx(type)) {\n    case kIrVector2:\n        if (strcmp(member, \"x\") == 0) {\n            gen_ir_vector2_x(build, result_reg, source_reg, pcpos);\n            return true;\n        }\n        if (strcmp(member, \"y\") == 0) {\n            gen_ir_vector2_y(build, result_reg, source_reg, pcpos);\n            return true;\n        }\n        break;\n\n    default:\n        break;\n    }\n    return false;\n}\n</code></pre> <p>We've made it! Now, when a Vector2's \"x\" property is accessed, Luau should properly generate the necessary IR code to fetch the property. The code for accessing \"y\" looks identical, except the <code>offsetof</code> macro references the \"y\" property instead: <code>offsetof(Vector2, y)</code>.</p>"},{"location":"guides/native-userdata.html#metamethods-and-namecalls","title":"Metamethods and Namecalls","text":"<p>We looked at \"access\" calls, e.g. accessing <code>Vector2.x</code>, but we skipped metamethod calls (<code>vec1 + vec2</code>) and namecalls (<code>vec1:Dot(vec2)</code>). These both have similar callbacks to the accessor callbacks. There are also similar callbacks for the builtin <code>vector</code> type. Including examples for all of these would be lengthy and repetitive. Instead, take a look at the <code>ConformanceIrHooks.h</code> file for examples of all of these callbacks.</p>"},{"location":"guides/native-userdata.html#caveats","title":"Caveats","text":"<ol> <li>This only applies to natively generated code.</li> <li>The type of the value must be known in the source code. <pre><code>--!native\n\nlocal function doThis(vec)\n    print(vec.x) -- \"vec\" is \"any\" and thus no IR lowering is applied\nend\n\nlocal function doThat(vec: Vector2)\n    print(vec.x) -- Receives IR-lowering, as \"vec\" is known to be \"Vector2\"\nend\n</code></pre></li> </ol>"},{"location":"guides/native.html","title":"Native Code Generation","text":"<p>Luau provides native code generation (NCG). This is a feature that must be explicitly enabled.</p> <p>The first step to enable NCG is to check if it is supported, and then create the code generator state. We will do this with the <code>luau_codegen_supported</code> and <code>luau_codegen_create</code> functions. Luau must be built with the CodeGen project for this to work.</p>"},{"location":"guides/native.html#enable","title":"Enable","text":"Enable NCG<pre><code>#include &lt;luacodegen.h&gt;\n\n// ...\n\nlua_State* L = luaL_newstate();\n\nif (luau_codegen_supported()) {\n    luau_codegen_create(L);\n}\n\nluaL_openlibs(L);\nluaL_sandbox(L);\n</code></pre>"},{"location":"guides/native.html#compile","title":"Compile","text":"<p>Next, when you load your script for execution, call <code>luau_codegen_compile(L, idx)</code>, where <code>idx</code> is the location of our loaded script.</p> Compile<pre><code>#include &lt;luacodegen.h&gt;\n\n// ...\n\nint res = luau_load(script, ...);\nif (res != 0) {\n    // handle error\n    return;\n}\n\nif (luau_codegen_supported()) {\n    luau_codegen_compile(script, -1);\n}\n</code></pre>"},{"location":"guides/native.html#enable-within-luau","title":"Enable Within Luau","text":"<p>With the above code, native codegen will always be generated for a given chunk. However, it is much preferred to allow the code itself to direct when and where native codegen should be utilized. This can be done with directives and function attributes. However, we first must change our above code to include compilation options.</p> Native Options<pre><code>#include &lt;Luau/CodeGen.h&gt; // Note that this is different than the previous examples\n\n// ...\n\nif (Luau::CodeGen::isSupported()) {\n    Luau::CodeGen::CompilationOptions native_opts{};\n\n    // Set the \"OnlyNativeModules\" flag for native compilation:\n    native_opts.flags = Luau::CodeGen::CodeGenFlags::CodeGen_OnlyNativeModules;\n\n    Luau::CodeGen::CompilationResult res = Luau::CodeGen::compile(script, -1, native_opts);\n    if (res.hasErrors()) {\n        // Optionally log out errors.\n        // This isn't fatal; and it might just be \"NothingToCompile\" or \"NotNativeModule\".\n    }\n}\n</code></pre> <p>With the <code>CodeGen_OnlyNativeModules</code> flag set, attempting to do native compilation will only affect Luau code that is explicitly marked with a native directive or function attribute. More info on these below.</p>"},{"location":"guides/native.html#native-directive","title":"Native Directive","text":"<p>By adding the <code>native</code> directive in our script, we signal to Luau that we would like the script to be natively compiled. Directives always go at the top of scripts and begin with <code>--!</code>.</p> <pre><code>--!native\n\nlocal function buildVectors()\n    local t = table.create(1024)\n    for i = 1, 1024 do\n        t[i] = vector.create(i, i, i)\n    end\n    return t\nend\n\nlocal function multiplyVectorsInPlace(vecs: { vector }, n: number)\n    for i in vecs do\n        vecs[i] *= n\n    end\nend\n\nlocal vecs = buildVectors()\nmultiplyVectorsInPlace(vecs, 5)\n</code></pre>"},{"location":"guides/native.html#native-function-attribute","title":"Native Function Attribute","text":"<p>Sometimes, it is undesirable to target native compilation for an entire script. Instead, it might be more beneficial to target specific functions. This can be done with the <code>@native</code> function attribute in Luau.</p> <pre><code>local function buildVectors() ... end\n\n@native\nlocal function multiplyVectorsInPlace(vecs: { vector }, n: number)\n    for i in vecs do\n        vecs[i] *= n\n    end\nend\n\nlocal vecs = buildVectors()\nmultiplyVectorsInPlace(vecs, 5)\n</code></pre> <p>To clarify, the <code>@native</code> attribute can be on the same line as the function definition. Do whatever is clearer for you and your team. It is also not necessary for the function to be local.</p> <pre><code>-- Various examples\n\n@native local function a() --[[ ... ]] end\n\n@native function b() --[[ ... ]] end\n\n@native\nfunction c() --[[ ... ]] end\n\n--\n\nlocal lib = {}\n\n@native function lib.foo() --[[ ... ]] end\n\nlib.bar = @native function() --[[ ... ]] end\n</code></pre>"},{"location":"guides/native.html#ir-lowering","title":"IR Lowering","text":"<p>While NCG might give a boost for built-in Luau libraries and functions, there is no real gain for custom userdata types out of the box.</p> <p>Luau includes APIs to generate IR (intermediate representation) code for userdata accesses, method calls, and some other metamethod calls. This may result in significant performance benefits.</p> <p>See the Native Userdata guide for more info.</p>"},{"location":"guides/native.html#profiling","title":"Profiling","text":"<p>NCG is not always going to be faster than normal Luau bytecode. As such, always profile and benchmark your code to understand if NCG is improving performance as expected. Experiment with directive-level and function-attribute-level NCG to understand which performs best for your code.</p>"},{"location":"guides/pinning.html","title":"Pinning and References","text":""},{"location":"guides/pinning.html#what-is-pinning","title":"What is Pinning?","text":"<p>Pinning is a process of forcing a piece of memory from moving or being deleted. In garbage-collected languages, the GC may move memory around for efficiency, and will also decide when to free the memory. In other words, the language is managing the memory.</p> <p>Luau is a memory-managed language. As such, the Luau GC has control of how memory is allocated, where it goes, and when it's freed. When working with data within Luau outside of its memory domain (e.g. within another language, memory-managed or not), we need to take special care of not accidentally using a piece of memory that vanishes. Luau won't move memory around, so we don't need to worry about the state of our pointers to userdata or buffers, but we do need to worry abou Luau deciding to free up memory. Therefore, when we talk about \"pinning\" with Luau objects, what we really mean is, \"don't delete this.\"</p> <p>Luau can only keep track of what exists within its domain. If you pull a value out of its domain, Luau has no way of knowing about it. Thus, the GC may determine there are no more references to the object within its known domain, and then delete it.</p> <p>If we want to keep Luau from freeing a value, we need a way to tell Luau, \"Hey, please don't free this value while I'm holding onto it.\" There are a few ways to do this.</p>"},{"location":"guides/pinning.html#pinning-on-the-stack","title":"Pinning on the Stack","text":"<p>One method of pinning is leaving a value on the stack. Of course, this has to be on the stack of a Luau thread that is also referenced elsewhere too (all values in Luau, including threads, are subject to being GC'd).</p> <p>You may already be doing this without realizing it. For instance, we keep new threads alive by keeping them on the stack where they were created until the thread is done. Failing to do so (i.e. popping it early) may result in the thread being GC'd and causing lots of fun problems.</p> <pre><code>lua_State* T = lua_newthread(L); // T is pushed to the stack of L (not going anywhere!)\n\n// ...push some function onto T, and maybe some args\nint status = lua_resume(T, nullptr, 0);\n// ...handle status\n\nlua_pop(L, 1); // Pop T from L. We no longer need it pinned. The GC is free to pick up T now.\n</code></pre>"},{"location":"guides/pinning.html#pinning-within-a-table","title":"Pinning within a Table","text":"<p>We can also pin a value by placing it into a table. This table also has to live somewhere that won't get GC'd either. We could create a table within the Luau registry and place our values there.</p> <pre><code>// store a ref\nvoid set_ref(lua_State* L, const char* name, int idx) {\n    idx = lua_absindex(idx);\n    luaL_findtable(L, LUA_REGISTRYINDEX, \"references\");\n    lua_pushvalue(L, idx);\n    lua_rawsetfield(L, -2, name); // references[name] = stack[idx]\n    lua_pop(L, 1); // pop 'references' table\n}\n\n// push value of ref to stack\nvoid get_ref(lua_State* L, const char* name) {\n    luaL_findtable(L, LUA_REGISTRYINDEX, \"references\");\n    lua_rawgetfield(L, -1, name);\n    lua_remove(L, -2); // pop 'references' table\n}\n\n// delete a ref\nvoid clear_ref(lua_State* L, const char* name) {\n    lua_pushnil(L);\n    set_ref(L, name, -1);\n    lua_pop(L, 1);\n}\n\n// Test:\nstruct Foo {};\nlua_pushuserdata(L, sizeof(Foo));\nset_ref(L, \"foo\", -1);\nlua_pop(L, 1); // pop userdata\n\nget_ref(L, \"foo\");\nFoo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, -1));\n\nclear_ref(L, \"foo\");\n</code></pre> <p>Well, that's a lot of work. And we could have skipped a lot of that by writing directly to the LUA_REGISTRYINDEX table anyway. But it's not very flexible for dynamic references, as we need a defined name per reference. What if we have a dynamic number of objects that all need their own reference?</p>"},{"location":"guides/pinning.html#pinning-with-lua_ref","title":"Pinning with lua_ref","text":"<p>Luau comes with a nifty reference system built-in. All we need to do is call <code>lua_ref</code> and it will hand us an integer as a reference to the object. Internally, this is storing the values within the Luau registry. We can call <code>lua_unref</code> to remove our reference and <code>lua_getref</code> to retrieve the value.</p> <p>By creating a reference to our object, we are inherently pinning the value. We can also create multiple references for a single object. Because this is storing the value within the Luau registry, the GC sees the value and won't delete it.</p> <p>So, in order to pin our desired value, we just need to use the built-in reference system.</p> <pre><code>struct Foo {};\nlua_pushuserdata(L, sizeof(Foo));\nint foo_ref = lua_ref(L, -1);\nlua_pop(L, 1); // pop userdata\n\nlua_getref(L, foo_ref);\nFoo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, -1));\n\nlua_unref(L, foo_ref);\n</code></pre>"},{"location":"guides/pinning.html#raii-and-shared-pointers","title":"RAII and Shared Pointers","text":"<p>Because <code>lua_ref</code> requires us to call <code>lua_unref</code> to free the reference, we can easily end up with the same memory leak bugs that plague unmanaged-memory languages. However, we can utilize modern concepts and features to help us out. Using shared pointers and RAII, we can easily encapsulate Luau references in a safer manner.</p> <pre><code>// This is just a bare-bones example.\n// Based on Lute's 'Ref' class: https://github.com/luau-lang/lute/blob/primary/lute/runtime/src/ref.cpp\n\nclass LuauRef {\nprivate:\n    int ref = LUA_NOREF;\n    lua_State* main;\n\npublic:\n    LuauRef(lua_State* L, int idx) {\n        ref = lua_ref(L, idx);\n        main = lua_mainthread(L);\n    }\n\n    ~LuauRef() {\n        lua_unref(main, ref);\n    }\n\n    // Push the value of the reference to the stack\n    void push(lua_State* L) {\n        lua_getref(L, ref);\n    }\n};\n\n// Using shared_ptr with LuauRef:\nlua_newuserdata(L, sizeof(Foo));\nstd::shared_ptr&lt;LuauRef&gt; ref = std::make_shared&lt;LuauRef&gt;(L, -1);\nlua_pop(L, 1);\n\n// Now we can pass \"ref\" around safely and retain our reference to our Foo userdata.\n// We can retrieve the value by calling 'push':\nref-&gt;push(L);\nFoo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, -1));\n</code></pre>"},{"location":"guides/sandboxing.html","title":"Sandboxing","text":""},{"location":"guides/sandboxing.html#the-problem","title":"The Problem","text":"<p>Consider loading untrusted Luau code. By default, all code will share the same global environment. If a malicious script decides to modify the global environment, this will affect all other scripts. Consider the following example:</p> Malicious Script<pre><code>local p = _G.print\n_G.print = function(...)\n    -- Still log things out so it appears as if all is normal:\n    p(...)\n\n    -- Intercept all print statements and send them off somewhere:\n    someHttpThing:Send(\"http_somewhere_bad\", {...})\nend\n</code></pre> Victim Script<pre><code>-- This seems to work, but the previous script has intercepted\n-- the message and sent it off to some malicious website.\nprint(\"Hello!\")\n</code></pre>"},{"location":"guides/sandboxing.html#sandboxing-state","title":"Sandboxing State","text":"<p>Sandboxing creates a safer environment for potentially untrusted Luau code. When sandboxing is enabled, all libraries, built-in metatables, and globals are set to read-only. There are also some performance benefits to sandboxing, and thus it is recommended to always turn it on.</p> <p>To turn on sandboxing, call <code>luaL_sandbox(L)</code> after opening up libraries and before loading any Luau code.</p> Sandboxing<pre><code>lua_State* L = luaL_newstate();\nluaL_openlibs(L);\n\nluaL_sandbox(L);\n</code></pre> <p>Now, if a malicous script attempts to modify the global state, an error will be thrown:</p> Malicous Attempt<pre><code>-- Throws an error: \"attempt to modify a readonly table\" (in this case, the _G global table)\n_G.print = function(...) end\n</code></pre> <p>However, we have introduced an undesired side-effect: We can now no longer create anything within the global scope. Consider the following snippet of unharmful Luau:</p> <pre><code>function add(a: number, b: number)\n    return a + b\nend\n</code></pre> <p>This would also throw the same error: <code>\"attempt to modify a readonly table\"</code>. In this particular example, writing <code>local function add(a, b)</code> would solve the issue. But this is enough friction to become problematic, especially for existing code. Thus, sandboxing our Luau state is not the final step. We need to do one more thing.</p>"},{"location":"guides/sandboxing.html#sandboxing-scripts","title":"Sandboxing Scripts","text":"<p>If we want our previous Luau code to work, we need to sandbox the script thread too. We can do this with the <code>luaL_sandboxthread</code> function. This function will create a proxy to our global <code>_G</code>. This is done by creating a new table for <code>_G</code>, and then assigning a metatable which has an <code>__index</code> field pointing to the original <code>_G</code> table.</p> <p>We want to do this along with sandboxing our top-level state. Sandbox the Luau state with <code>luaL_sandbox</code>, and then sandbox each script execution with <code>luaL_sandboxthread</code>.</p> <p>Note: This operation should be done per logical \"script\" and not for every single thread created. Doing this for every thread can lead to performance issues and also recursive depth errors, due to long <code>__index</code> chains to get back to the original <code>_G</code> table. Thus, only call <code>luaL_sandboxthread</code> for a thread that acts as the top-level state for a given script. Any threads created from this thread will also inherit this proxied global table.</p> Sandboxing Thread<pre><code>// Call run_script AFTER we have sandboxed our initial state\nstatic int run_script(lua_State* L, const std::string&amp; name, const std::string&amp; bytecode) {\n    // Create a thread to act as our script environment:\n    lua_State* script = lua_newthread(L);\n\n    // Sandbox it:\n    luaL_sandboxthread(script);\n\n    // Load our bytecode onto the script thread:\n    int res = luau_load(script, (std::string(\"=\") + name).c_str(), bytecode.data(), bytecode.length(), 0);\n\n    if (res != 0) {\n        // ...handle error\n        return res;\n    }\n\n    // Run the script:\n    int status = lua_resume(script, nullptr, 0);\n    if (status != LUA_OK) {\n        // ...handle error status or yield status\n    }\n\n    // Pop script thread off of 'L'\n    lua_pop(L, 1);\n}\n\nstatic void example() {\n    lua_State* L = luaL_newstate();\n    luaL_openlibs(L);\n    luaL_sandbox(L);\n\n    std::string bytecode = compile_script(some_sourcecode);\n    run_script(L, \"example\", bytecode);\n\n    lua_close(L);\n}\n</code></pre> <p>With this example, we can run multiple different scripts with <code>run_script</code>. Each script could modify their own global environment without affecting the global environment of other scripts. In other words, their environment has been sandboxed!</p> <p>For more information, visit the official Luau page about sandboxing.</p>"},{"location":"guides/setup.html","title":"Setup","text":""},{"location":"guides/setup.html#project-setup","title":"Project Setup","text":"<p>Important notes about Luau, many of which are pulled from the Luau readme:</p> <ul> <li>Runtime requires C++11 minimum.</li> <li>Compiler and analysis libraries require C++17 minimum.</li> <li>Licensed under the MIT license.</li> <li>cmake is the primary tool used for building Luau</li> </ul> <p>This guide does not seek to teach cmake, or any other build tool for that matter. It is assumed that the reader can set up a C++ project targeting Luau.</p> <p>Luau is split up into various build projects. For creating a project that embeds Luau, the common projects used are: VM, Compiler, Ast, CodeGen, Require, and Common.</p> <ul> <li>VM: Virtual machine. This handles running Luau, and includes many of the C APIs that are commonly used to interface with Luau.</li> <li>Compiler: Handles compiling Luau to bytecode.</li> <li>Ast: Abstract syntax tree. This is used by the compiler.</li> <li>CodeGen: Native code generation (NCG). This allows Luau to generate native code. It can be thought of as a hybrid between AOT and JIT, as it compiles against bytecode that is already loaded in the VM.</li> <li>Require: Adds require-by-string functionality.</li> <li>Common: Common/shared utilities and resources, such as all the bytecode opcodes.</li> </ul>"},{"location":"guides/setup.html#new-vm-instance","title":"New VM Instance","text":"<p>To create a new Luau VM instance, call either <code>lua_newstate</code> or <code>luaL_newstate</code>. The former allows you to assign your own allocator, along with an opaque pointer to arbitrary data. The latter will use a default allocator.</p> <p>The default allocator looks like this: Allocator<pre><code>static void* allocator(void* ud, void* ptr, size_t old_size, size_t new_size) {\n    // 'ud' is the pointer passed as the second argument to `lua_newstate`\n\n    (void)ud; (void)old_size; // Not using these\n\n    // new_size of 0 signals that the allocator should free the memory\n    if (new_size == 0) {\n        free(ptr);\n        return nullptr;\n    }\n\n    return realloc(ptr, new_size);\n}\n</code></pre></p> New State<pre><code>// Create a Luau state with a specified allocator:\nlua_State* L = lua_newstate(allocator, nullptr);\n\n// Use the default allocator:\nlua_State* L = luaL_newstate();\n</code></pre>"},{"location":"guides/setup.html#libraries","title":"Libraries","text":"<p>Once our Luau state is open, we need to load the default libraries. The easiest way to do this is by calling <code>luaL_openlibs(L)</code>, which opens up all of the built-in libraries. Alternatively, if opening all of the libraries is not desired, individual built-in ones can be opened using their respective open function, e.g. <code>luaopen_os(L)</code>.</p> <p>You may also have your own custom libraries. Open these right after opening the built-in libraries.</p> Libraries<pre><code>lua_State* L = luaL_newstate();\n\nluaL_openlibs(L);\n</code></pre>"},{"location":"guides/setup.html#sandboxing","title":"Sandboxing","text":"<p>Sandboxing creates a safer environment for potentially untrusted Luau code. To turn on sandboxing, call <code>luaL_sandbox(L)</code> after opening up libraries and before loading any Luau code.</p> Sandboxing<pre><code>lua_State* L = luaL_newstate();\nluaL_openlibs(L);\n\nluaL_sandbox(L);\n</code></pre> <p>See the Sandboxing guide for more information.</p>"},{"location":"guides/setup.html#closing","title":"Closing","text":"<p>States need to be closed once completed with them.</p> Closing<pre><code>lua_close(L);\n</code></pre>"},{"location":"guides/setup.html#raii","title":"RAII","text":"<p>Since Luau state is initialized and destroyed via C API functions, it is useful to bind the lifetime of Luau using the RAII idiom to prevent leaking the state.</p> <p>A common pattern is to wrap the Luau state in its own class.</p> <pre><code>class LuauState {\n    lua_State* L;\n\npublic:\n    LuauState() : L(luaL_newstate()) {\n        // state setup\n        luaL_openlibs(L);\n        luaL_sandbox(L);\n    }\n    ~LuauState() {\n        lua_close(L);\n    }\n};\n</code></pre> <p>Smarter pointers would also work. However, using a class allows you to encapsulate the setup behavior of the state too, such as opening up libraries and enabling sandboxing.</p>"},{"location":"guides/stack.html","title":"Stack","text":"<p>TODO. Guide on navigating the Luua stack with the C API. Pushing, popping, inserting, replacing, positive/negative indices, growing, when to use absolute index, etc.</p>"},{"location":"guides/tables.html","title":"Tables","text":"<p>Coming soon. Table manipulation. Generating, reading, writing, iterating, etc.</p>"},{"location":"guides/tags.html","title":"Tags","text":"<p>Tags are a simple way to interrogate what \"type\" of userdata we are dealing with.</p>"},{"location":"guides/tags.html#the-problem","title":"The Problem","text":"<p>Consider the following example. We have two structs, Foo and Bar. These will be our userdata. Let's say we already have code to construct these values from Luau, such as <code>newFoo()</code> and <code>newBar()</code>. Userdata structs<pre><code>struct Foo {\n    char* data;\n    size_t data_len;\n};\n\nstruct Bar {\n    int n;\n};\n\nint new_foo(lua_State* L) {\n    void* foo = lua_newuserdata(L, sizeof(Foo));\n    foo-&gt;data = nullptr;\n    foo-&gt;data_len = 0;\n    return 1;\n}\n\nint new_bar(lua_State* L) {\n    void* bar = lua_newuserdata(L, sizeof(Bar));\n    bar-&gt;n = 0;\n    return 1;\n}\n</code></pre></p> Creating userdata from Luau<pre><code>local foo = newFoo()\nlocal bar = newBar()\n</code></pre> <p>Now, let's add a function into the mix. This function wants to take an instance of \"Foo\" and print out its \"data_len\" property. However, how can we check if the value is actually Foo? We can at least verify it's a userdata, but nothing much more yet: Print Foo Data Length<pre><code>int print_foo_data_len(lua_State* L) {\n    luaL_argexpected(L, lua_isuserdata(L, 1), 1, \"userdata\");\n\n    // Hoping for the best that the user gave us the right userdata:\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n\n    printf(\"data_len: %zu\\n\", foo-&gt;data_len);\n}\n</code></pre></p> Luau Usage<pre><code>printFooDataLen(foo) -- works\nprintFooDataLen(bar) -- UB, likely to crash our whole program\n</code></pre> <p>How can we solve this?</p>"},{"location":"guides/tags.html#named-metatables","title":"Named Metatables","text":"<p>One solution to this is by using named metatables. When we create our userdata, we can build a metatable using <code>luaL_newmetatable</code> and bind it to the userdata. Metatables built in this manner have names. And Luau comes with <code>luaL_checkudata</code>, which lets us check to see if we have a matching metatable attached.</p> <p>Let's change up our Foo and Bar constructor code just a bit: Named Metatables<pre><code>int new_foo(lua_State* L) {\n    void* foo = lua_newuserdata(L, sizeof(Foo));\n    // ...\n\n    if (luaL_newmetatable(L, \"Foo\")) {\n        // ...populate metatable\n    }\n    lua_setmetatable(L, -2); // bind metatable to foo\n\n    return 1;\n}\n\nint new_bar(lua_State* L) {\n    void* bar = lua_newuserdata(L, sizeof(Bar));\n    // ...\n\n    if (luaL_newmetatable(L, \"Bar\")) {\n        // ...populate metatable\n    }\n    lua_setmetatable(L, -2); // bind metatable to bar\n\n    return 1;\n}\n</code></pre></p> <p>Now we can change our <code>print_foo_data_len</code> function to use <code>luaL_checkudata</code>. If the value isn't a userdata with the \"Foo\" metatable attached, an error will be thrown: <pre><code>int print_foo_data_len(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(luaL_checkudata(L, 1, \"Foo\"));\n    printf(\"data_len: %zu\\n\", foo-&gt;data_len);\n}\n</code></pre></p> Luau Usage<pre><code>printFooDataLen(foo) -- works\nprintFooDataLen(bar) -- throws Luau error safely (good!)\n</code></pre> <p>This solves our initial problem. However, there's a couple performance considerations:</p> <ol> <li>Calling <code>luaL_checkudata</code> can be expensive. It needs to fetch the metatable from the userdata, attempt to fetch the metatable from the Luau registry, and then compare the two.</li> <li>We have to call <code>luaL_newmetatable</code> for each new instance of our userdata. This function is idempodent; it will only create one metatable per provided name. However, it still has to reach into the Luau registry and see if it finds an existing metatable first.</li> </ol>"},{"location":"guides/tags.html#tags-to-the-rescue","title":"Tags to the Rescue","text":"<p>Tags allow us to assign an integer to represent our userdata type. This is just an arbitrary number that we choose, which should be unique per userdata type. By using tags, we can now ensure we have the proper userdata type by quickly comparing two numbers. This is much faster than doing hash lookups with <code>luaL_checkudata</code>.</p> <p>Another benefit is that we can create our metatable ahead of time, and then use <code>lua_newuserdatataggedwithmetatable</code> (what a long name!) to create our userdata with a given tag and metatable.</p> <p>First, we need to define our tags per userdata. Note that <code>0</code> is the default tag given to userdata, so we will want to avoid <code>0</code>. Tag Definitions<pre><code>constexpr int kFooTag = 1;\nconstexpr int kBarTag = 2;\n</code></pre></p> <p>Next, we need to define our metatable ahead of time. This is a function we probably call at the same time that we are opening up our libraries. <pre><code>void setup_foo(lua_State* L) {\n    luaL_newmetatable(L, \"Foo\");\n    // ...populate metatable\n    lua_setuserdatametatable(L, kFooTag); // bind our metatable to our tag\n\n    // OPTIONAL: If we need a destructor, we can assign that here too\n    lua_setuserdatadtor(L, kFooTag, [](lua_State* L, void* ptr) {\n        Foo* f = static_cast&lt;Foo*&gt;(ptr);\n        // free resources as needed\n        delete f-&gt;data;\n    });\n}\n\n// ...same type of code for setting up 'Bar'\n</code></pre></p> <p>Now we can change our constructor functions to automatically set our tag and metatable: <pre><code>int new_foo(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatataggedwithmetatable(L, sizeof(Foo), kFooTag));\n    foo-&gt;data = nullptr;\n    foo-&gt;data_len = 0;\n    // Note how we no longer have to put code here to create and bind the metatable (it's already done!)\n    return 1;\n}\n</code></pre></p> <p>Finally, we can now quickly check that we have the correct userdata by interrogating the tag.</p> <pre><code>// The \"lua_touserdatatagged\" function returns NULL if our value isn't correct. But we\n// want to throw an error. So we'll add this helper function for asserting the userdata:\nstatic Foo* check_foo(lua_State* L, int idx) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdatatagged(L, idx, kFooTag));\n    luaL_argcheck(L, foo, idx, \"expected Foo\");\n    return foo;\n}\n\nint print_foo_data_len(lua_State* L) {\n    Foo* foo = check_foo(L, 1);\n    printf(\"data_len: %zu\\n\", foo-&gt;data_len);\n}\n</code></pre> <p>By using tags, we:</p> <ol> <li>Ensure that we are casting userdata to the correct type</li> <li>Speed up construction of userdata, since we assign the metatable and destructor ahead of time</li> <li>Speed up checking the userdata type, since we only need to compare numeric tags rather than fetch and compare metatables</li> </ol>"},{"location":"guides/tags.html#final-notes","title":"Final Notes","text":""},{"location":"guides/tags.html#max-tags","title":"Max Tags","text":"<p>As of writing this, Luau has a tag limit of 128 (including 0, so technically 127 slots available). This is defined by the <code>LUA_UTAG_LIMIT</code> constant.</p>"},{"location":"guides/tags.html#sharing-tags","title":"Sharing Tags","text":"<p>An easy way to keep your tags organized is by creating a single header file that defines each tag. And as a simple reminder of the limit, it is nice to start at the max tag number and count down.</p> <pre><code>// userdata_tags.h\n#pragma once\n\nconstexpr int kFooTag = 127;\nconstexpr int kBarTag = 126;\nconstexpr int kBazTag = 125;\n// ...\n</code></pre>"},{"location":"guides/threads.html","title":"Threads","text":"<p>Coming soon. Coroutine threads. How to create a thread and run it. Responding to thread status. Stack hygiene, e.g. ensuring stack is clear after thread is done (otherwise thread status can be incorrect). etc.</p>"},{"location":"guides/userdata.html","title":"Userdata","text":"<p>In Luau, userdata is a special type that allows you to create arbitrary data. This data is created and managed by Luau. We can even attach metatables to userdata to give them special behavior, such as properties and methods.</p> <p>Through this guide, we will work our way toward building a full-featured userdata type, with a constructor, destructor, fields, methods, tags, atoms, and more.</p> <p>Userdata is created with the <code>lua_newuserdata</code> function:</p> Create Userdata<pre><code>void* data = lua_newuserdata(L, 16); // Create userdata of 16 bytes\n</code></pre> <p>When we do this, Luau is allocating a chunk of memory for us. Importantly, Luau is managing this data; it is subject to removal by the garbage collector. Thus, holding onto a userdata without first pinning the value can be dangerous.</p> <p>Buffers</p> <p>If all we need is just a chunk of arbitrary data managed by Luau, consider using buffers instead.</p>"},{"location":"guides/userdata.html#struct-as-userdata","title":"Struct as Userdata","text":"<p>A common practice is to shape our userdata around a struct. This is as simple as creating a userdata with the same size as our struct and casting the value accordingly.</p> Userdata Struct<pre><code>struct Foo {\n    int num;\n    char* data;\n    size_t data_size;\n};\n\n// Create userdata the same size as Foo and cast to Foo:\nFoo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n\n// Initialize fields:\nfoo-&gt;num = 0;\nfoo-&gt;data = nullptr;\nfoo-&gt;data_size = 0;\n</code></pre> <p>Zero-initialization</p> <p>Luau gives us a chunk of memory, but it is not zero-initialized. Ensure that you initialize all fields for your userdata, just as it's shown in the example above. C++'s placement new operator can be used as an easy way to zero-initialize, seen below.</p> <p>Alternatively, C++'s placement new operator can be used to initialize data. This is a safe way to ensure your data is zero-initialized.</p> Placement New<pre><code>// Must include 'new' to use placement-new\n#include &lt;new&gt;\n\n// ...\n\nFoo* foo = new (lua_newuserdata(L, sizeof(Foo))) Foo{};\n// foo is zero-initialized, so no need to manually do so.\n</code></pre>"},{"location":"guides/userdata.html#foo-library","title":"Foo Library","text":"<p>Right now, we've simply shown code for creating userdata. But how can we expose this to Luau? Let's create a <code>Foo</code> library that contains a single <code>new</code> function. This will be our constructor. From Luau, we will be able to call <code>Foo.new()</code> to construct a new Foo object.</p> <pre><code>// This is our Foo constructor\nstatic int Foo_new(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n    foo-&gt;num = 0;\n    foo-&gt;data = nullptr;\n    foo-&gt;data_size = 0;\n    return 1;\n}\n\nstatic const luaL_Reg foo_lib[] = {\n    {\"new\", Foo_new},\n    {nullptr, nullptr},\n}\n\n// Call this when we open other libraries on startup\nvoid open_Foo(lua_State* L) {\n    luaL_register(L, \"Foo\", foo_lib);\n    lua_pop(L, 1);\n}\n</code></pre> <p>From Luau, we can now construct Foo:</p> <pre><code>local foo = Foo.new()\nprint(type(foo)) -- \"userdata\"\n</code></pre> <p>That's great, but how do we give this purpose within our Luau code? It's meaningless at the moment. Luau code could figure out that it's a userdata value, but that's it. In order to give more behavior to our userdata, we need to attach a metatable. The metatable will describe what should happen when Luau code attempts to interact with Foo.</p>"},{"location":"guides/userdata.html#foo-metatable","title":"Foo Metatable","text":"<p>We can see that Foo has a <code>num</code> field. Let's add a way to read and write this value from Luau, as well as handle methods. We can do this by assigning a metatable with the <code>__index</code>, <code>__newindex</code>, and <code>__namecall</code> fields pointing to our own custom functions.</p> <p>First, let's create the metatable. Instead of simply creating a table and assigning it as a metatable, we're going to use the special <code>luaL_newmetatable</code> function. This function creates or fetches a table with a given name, which will allow us to do some more nifty tricks later.</p> <pre><code>constexpr const char* kFooName = \"Foo\";\n\n// Metamethod stubs:\nstatic int Foo_index(lua_State* L) { /* ... */ }\nstatic int Foo_newindex(lua_State* L) { /* ... */ }\nstatic int Foo_namecall(lua_State* L) { /* ... */ }\n\n// Map out our metatable:\nstatic const luaL_Reg foo_mt[] = {\n    {\"__index\", Foo_index},\n    {\"__newindex\", Foo_newindex},\n    {\"__namecall\", Foo_namecall},\n    {nullptr, nullptr},\n};\n\nstatic int Foo_new(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdata(L, sizeof(Foo)));\n    // ...initialize foo fields\n\n    // luaL_newmetatable returns true if the table was just created, thus we need\n    // to populate its fields. It returns false if it already exists. In either case,\n    // it is pushed to the stack.\n    if (luaL_newmetatable(L, kFooName)) {\n        // Assign our metatable functions:\n        luaL_register(L, nullptr, foo_mt);\n\n        // We can also assign a type, which is returned from Luau's \"typeof\" function:\n        lua_pushliteral(L, \"Foo\");\n        lua_rawsetfield(L, -2, \"__type\");\n    }\n\n    // Assign the metatable to our userdata:\n    lua_setmetatable(L, -2);\n\n    return 1;\n}\n</code></pre>"},{"location":"guides/userdata.html#read-and-write","title":"Read and Write","text":"<p>Now that we've set up our metatable, let's fill out our metamethods. We'll start with the <code>__index</code> handler.</p> <pre><code>static int Foo_index(lua_State* L) {\n    // Foo is at index 1 on the stack:\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n\n    // The key is at index 2. We only want to allow string indexing, so we'll use checkstring:\n    const char* key = luaL_checkstring(L, 2);\n\n    // Access our \"num\" field:\n    if (strcmp(key, \"num\") == 0) {\n        lua_pushinteger(L, foo-&gt;num);\n        return 1;\n    }\n\n    // Throw an error if the given key didn't match anything:\n    luaL_error(L, \"unknown property: %s\", key);\n}\n</code></pre> <p>From Luau, we can now read <code>num</code>: <pre><code>local foo = Foo.new()\nprint(foo.num) -- 0\n</code></pre></p> <p>But we still can't write to <code>num</code>. Let's fix that. Our code within <code>Foo_newindex</code> will look similar to <code>Foo_index</code>, except we will have an extra argument on the stack (the value being set).</p> <pre><code>static int Foo_newindex(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n    const char* key = luaL_checkstring(L, 2);\n\n    // Access our \"num\" field:\n    if (strcmp(key, \"num\") == 0) {\n        int n = luaL_checkinteger(L, 3); // Ensure the argument is actually a number\n        foo-&gt;num = n;\n    }\n\n    luaL_error(L, \"unknown property: %s\", key);\n}\n</code></pre> <p>Our Luau code can now assign <code>num</code>: <pre><code>local foo = Foo.new()\nfoo.num = 15\nprint(foo.num) -- 15\n</code></pre></p>"},{"location":"guides/userdata.html#methods","title":"Methods","text":"<p>We can assign methods to our userdata by utilizing the <code>__namecall</code> metatable field. When Luau calls a method (e.g. <code>foo:DoSomething()</code>), the <code>__namecall</code> metamethod will be triggered. We can use <code>lua_namecallatom</code> to fetch the name of the called method and figure out where to go from there. Let's fill out our <code>Foo_namecall</code> function to add a method for checking if the <code>num</code> field is even or odd.</p> <p>We'll create a separate function for our actual method. This is just a matter of keeping things tidy (insert whatever code principle you want). It could be inlined, but that's not easily maintainable for a large collection of methods.</p> Method Handling<pre><code>static int Foo_IsNumEven(lua_State* L) { /* ... */ }\n\nstatic int Foo_namecall(lua_State* L) {\n    // The `nemcallatom` function grabs the method name being called. We are keeping\n    // the `atom` argument null, but we'll come back to that later.\n    const char* method = lua_namecallatom(L, nullptr);\n\n    // Call our IsNumEven method:\n    if (strcmp(method, \"IsNumEven\") == 0) {\n        return Foo_IsNumEven(L);\n    }\n\n    luaL_error(L, \"unknown method %s\", method);\n}\n</code></pre> <p>Our <code>Foo_IsNumEven</code> function will look like any other Luau C function. We'll grab Foo from its first position on the stack, and push a boolean indicating whether or not its <code>num</code> field is even.</p> IsEven Method<pre><code>static int Foo_IsNumEven(lua_State* L) {\n    // Foo is at index 1. Any method arguments would come right after it.\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n\n    lua_pushboolean(L, foo-&gt;num % 2 == 0);\n    return 1;\n}\n</code></pre> <p>Let's try it out from Luau:</p> <pre><code>local foo = Foo.new()\n\nfoo.num = 10\nprint(foo:IsNumEven()) -- true\n\nfoo.num = 7\nprint(foo:IsNumEven()) -- false\n</code></pre>"},{"location":"guides/userdata.html#destructors","title":"Destructors","text":"<p>If our userdata value holds onto memory that we manage (e.g. we malloc a chunk of memory and store it in the userdata), then we need a way to free this memory when our userdata is freed by the garbage collector.</p> <p>Luau allows us to bind a destructor function to our userdata. It's not very safe to access our Luau state from these destructors, but we can access our userdata value and free up any resources.</p> <p>Note how our Foo struct has a <code>char* data</code> field. We haven't used this at all yet, but let's pretend we're using this field for some purpose. <pre><code>void create_data(Foo* foo, size_t size) {\n    foo-&gt;data = new char[size];\n    foo-&gt;data_size = size;\n}\n</code></pre></p> <p>There are a couple ways we can bind a destructor to a userdata value. We'll look at <code>lua_newuserdatadtor</code> first, and look at the other way later on in this guide. This works just like our original <code>lua_newuserdata</code> function, except it accepts an additional destructor function argument. We'll just create this inline with a lambda function.</p> <pre><code>static int Foo_new(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_newuserdatadtor(L, sizeof(Foo), [](void* ptr) {\n        // This function is called when the userdata is about to be GC'd.\n        // The `ptr` parameter is our userdata.\n        Foo* f = static_cast&lt;Foo*&gt;(ptr);\n\n        // Free up resources\n        delete[] f-&gt;data;\n    }));\n\n    // ...\n}\n</code></pre>"},{"location":"guides/userdata.html#other-metatable-fields","title":"Other Metatable Fields","text":"<p>We are not limited to just <code>__index</code>, <code>__newindex</code>, and <code>__namecall</code>. We can use any of the metatable fields. Here is a non-exhaustive example of other metamethod fields for our Foo userdata:</p> <pre><code>// __tostring\nstatic int Foo_tostring(lua_State* L) {\n    Foo* foo = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n    lua_pushfstring(L, \"Foo { num: %d, data_size: %zu }\", foo-&gt;num, foo-&gt;data_size);\n    return 1;\n}\n\n// __eq\nstatic int Foo_eq(lua_State* L) {\n    Foo* lhs = static_cast&lt;Foo*&gt;(lua_touserdata(L, 1));\n    Foo* rhs = static_cast&lt;Foo*&gt;(lua_touserdata(L, 2));\n\n    lua_pushboolean(\n        L,\n        lhs-&gt;num == rhs-&gt;num &amp;&amp;\n        lhs-&gt;data_size == rhs-&gt;data_size &amp;&amp;\n        memcmp(lhs-&gt;data, rhs-&gt;data, lhs-&gt;data_size) == 0\n    );\n}\n</code></pre>"},{"location":"guides/userdata.html#improvements","title":"Improvements","text":""},{"location":"guides/userdata.html#tags","title":"Tags","text":"<p>There are a few ways for us to improve on our existing code. One such improvements would be to utilize userdata tags. Check out the Tags guide for a detailed overview on setting up userdata tags and why they are beneficial. When we use tags, this also frees us up to move our metatable construction and destructor assignment elsewhere at startup. We then get to use the longest function name in existence: <code>lua_newuserdatataggedwithmetatable</code> (new userdata, tagged, with metatable).</p>"},{"location":"guides/userdata.html#atoms","title":"Atoms","text":"<p>Another improvement is to use Atoms. Similar to tags, atoms assign unique numbers to strings, allowing us to do much quicker comparisons within our metamethods, e.g. deciding which method to use.</p>"}]}